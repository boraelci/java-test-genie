@Test public void testExecute() throws Exception{ RosetteApiWrapper rosAPI = new RosetteApiWrapper("apiKey"); String tag = "tag"; String description = "description"; String processorType = "processorType"; String inputField = "inputField"; String targetField = "targetField"; RosetteAbstractProcessor processor = new RosetteAbstractProcessor(rosAPI, tag, description, processorType, inputField, targetField); IngestDocument document = new IngestDocument(); document.setFieldValue(inputField, "Hello world!"); IngestDocument result = processor.execute(document); assertEquals(result.getFieldValue(inputField), "Hello world!"); assertEquals(result.getFieldValue(targetField), processorType); }
@Test public void formatToUserFriendlyFormat_ReturnsFormattedString() { DateHelper dateHelper = new DateHelper(); Date date = new Date(); String userFriendlyFormat = dateHelper.formatToUserFriendlyFormat(date); assertNotNull(userFriendlyFormat); }
@Test public void testHasDescription() { UiLesson lesson = new UiLesson(); assertFalse(lesson.hasDescription()); lesson.description = ""; assertFalse(lesson.hasDescription()); lesson.description = "This is a lesson"; assertTrue(lesson.hasDescription()); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0, 10); FieldValue value = FieldValueUtil.create(5.0); FieldValue normalizedValue = NormalizationUtil.normalize(normContinuous, value); double expected = 0.5; double delta = 0.00001; assertEquals(expected, normalizedValue.asNumber().doubleValue(), delta); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); assertNotNull(FunctionUtil.evaluate(apply, values, context)); }
@Test public void testGetResultDataType() { DataType a = DataType.STRING; DataType b = DataType.NUMBER; DataType expectedResult = DataType.OBJECT; assertEquals(expectedResult, TypeUtil.getResultDataType(a, b)); }
@Test public void testDenormalize() { NormContinuous normContinuous = new NormContinuous(); List<LinearNorm> linearNorms = new ArrayList<>(); linearNorms.add(new LinearNorm(0, 0)); linearNorms.add(new LinearNorm(50, 100)); linearNorms.add(new LinearNorm(100, 200)); normContinuous.setLinearNorms(linearNorms); double value = 75; double result = NormalizationUtil.denormalize(normContinuous, value); assertEquals(150, result, 0.001); }
@Test public void testMatch(){ Map<String, FieldValue> values = new HashMap<>(); values.put("name", new FieldValue("John")); values.put("age", new FieldValue("30")); values.put("email", new FieldValue("john@example.com")); Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "name", "John"); table.put(1, "age", "30"); table.put(1, "email", "john@example.com"); Map<String, String> expected = table.row(1); assertEquals(expected, InlineTableUtil.match(table, values)); }
@Test public void testIsZero() { assertTrue(VerificationUtil.isZero(0.0, 0.1)); assertFalse(VerificationUtil.isZero(0.5, 0.1)); assertTrue(VerificationUtil.isZero(-0.0, -0.1)); assertFalse(VerificationUtil.isZero(-0.5, -0.1)); assertTrue(VerificationUtil.isZero(0.0, 0.0)); assertFalse(VerificationUtil.isZero(0.5, 0.0)); assertFalse(VerificationUtil.isZero(-0.5, 0.0)); }
@Test public void testEvaluateConstant() { Constant constant = new Constant("5", DataType.INTEGER); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue = ExpressionUtil.evaluateConstant(constant, context); assertEquals(DataType.INTEGER, fieldValue.getDataType()); assertNull(fieldValue.getField()); assertEquals("5", fieldValue.getValue()); }
@Test public void testUnmarshal() { FieldName name1 = new FieldName("test"); FieldName name2 = FieldName.unmarshal("test"); assertNotNull(name2); assertEquals(name1, name2); }
@Test public void testEvaluateSimilarity() { ComparisonMeasure comparisonMeasure = new ComparisonMeasure(); comparisonMeasure.setMeasure(new Jaccard()); List<ComparisonField> comparisonFields = new ArrayList<>(); comparisonFields.add(new ComparisonField()); comparisonFields.add(new ComparisonField()); comparisonFields.add(new ComparisonField()); BitSet flags = new BitSet(3); flags.set(0); flags.set(2); BitSet referenceFlags = new BitSet(3); referenceFlags.set(0); referenceFlags.set(1); double result = MeasureUtil.evaluateSimilarity(comparisonMeasure, comparisonFields, flags, referenceFlags); assertEquals(0.25, result, 0.001); }
@Test public void testParse() { Object obj = TypeUtil.parse(DataType.STRING, "hello"); assertEquals("hello", obj); obj = TypeUtil.parse(DataType.INTEGER, "123"); assertEquals(123, obj); obj = TypeUtil.parse(DataType.FLOAT, "123.45"); assertEquals(123.45f, obj); obj = TypeUtil.parse(DataType.DOUBLE, "123.45"); assertEquals(123.45, obj); obj = TypeUtil.parse(DataType.BOOLEAN, "true"); assertEquals(true, obj); obj = TypeUtil.parse(DataType.DATE, "2022-11-22"); assertEquals(LocalDate.of(2022, 11, 22), obj); obj = TypeUtil.parse(DataType.TIME, "12:30"); assertEquals(LocalTime.of(12, 30), obj); obj = TypeUtil.parse(DataType.DATE_TIME, "2022-11-22 12:30"); assertEquals(LocalDateTime.of(2022, 11, 22, 12, 30), obj); obj = TypeUtil.parse(DataType.DATE_DAYS_SINCE_1960, "10000"); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1960, LocalDate.of(1986, 1, 26)), obj); obj = TypeUtil.parse(DataType.DATE_DAYS_SINCE_1970, "10000"); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1970, LocalDate.of(1970, 4, 27)), obj); obj = TypeUtil.parse(DataType.DATE_DAYS_SINCE_1980, "10000"); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1980, LocalDate.of(1997, 2, 19)), obj); obj = TypeUtil.parse(DataType.TIME_SECONDS, "45000"); assertEquals(new SecondsSinceMidnight(12, 30), obj); obj = TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1960, "1267292256"); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1960, LocalDateTime.of(2010, 2, 27, 4, 17, 36)), obj); obj = TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1970, "1267292256"); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1970, LocalDateTime.of(2010, 2, 27, 4, 17, 36)), obj); obj = TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1980, "1267292256"); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1980, LocalDateTime.of(2010, 2, 27, 4, 17, 36)), obj); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("John")); values.add(new FieldValue("Doe")); Apply apply = new Apply("concat", values); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue("JohnDoe"), result); }
@Test public void testBinaryXor() { assertTrue(PredicateUtil.binaryXor(true, false)); assertTrue(PredicateUtil.binaryXor(false, true)); assertFalse(PredicateUtil.binaryXor(true, true)); assertFalse(PredicateUtil.binaryXor(false, false)); assertNull(PredicateUtil.binaryXor(null, true)); assertNull(PredicateUtil.binaryXor(true, null)); assertNull(PredicateUtil.binaryXor(null, null)); }
@Test public void testDecodeComputable() { Computable mockComputable = Mockito.mock(Computable.class); Mockito.when(mockComputable.getResult()).thenReturn("Mock Computable Object"); Object object = EvaluatorUtil.decode(mockComputable); assertEquals("Mock Computable Object", object); }
@Test public void evaluateTest() { Apply apply = new Apply("functionName"); List<FieldValue> values = Arrays.asList(new FieldValue("value1"), new FieldValue("value2")); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void matchTest(){ Table<Integer, String, String> table = HashBasedTable.create(); Map<String, FieldValue> values = new HashMap<>(); values.put("name", new FieldValue("John")); table.put(1, "name", "John"); table.put(1, "age", "25"); Map<String, String> expected = new HashMap<>(); expected.put("name", "John"); expected.put("age", "25"); assertEquals(expected, InlineTableUtil.match(table, values)); }
@Test public void testEvaluate() { Apply apply = new Apply("function"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FunctionUtil.evaluate(apply, values, context); }
@Test public void testEvaluateMapValues() { Map<String, FieldValue> map = new LinkedHashMap<>(); map.put("column1", new FieldValue("value1")); map.put("column2", new FieldValue(2)); map.put("column3", new FieldValue(true)); MapValues mapValues = new MapValues(DataType.STRING, "missing", new ArrayList<FieldColumnPair>(Arrays.asList(new FieldColumnPair("field1", "column1"), new FieldColumnPair("field2", "column2"), new FieldColumnPair("field3", "column3")))); EvaluationContext context = new EvaluationContext(); assertEquals(FieldValueUtil.create(DataType.STRING, "missing", null), ExpressionUtil.evaluateMapValues(mapValues, context)); context.setFieldValue("field1", new FieldValue("value1")); context.setFieldValue("field2", new FieldValue(2)); context.setFieldValue("field3", new FieldValue(true)); assertEquals(new FieldValue(map), ExpressionUtil.evaluateMapValues(mapValues, context)); }
@Test public void testEvaluateNormContinuous() { NormContinuous nc = new NormContinuous(field, strategy, targetValue, defaultValue, mapMissingTo, mapMissingTo); EvaluationContext ec = new EvaluationContext(); ec.set("field", FieldValueUtil.create(value)); FieldValue result = ExpressionUtil.evaluateNormContinuous(nc, ec); Assert.assertNotNull(result); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(); FieldValue value = FieldValueUtil.create(10.0); double normalizedValue = NormalizationUtil.normalize(normContinuous, value); assertEquals(normalizedValue, 0.5, 0.001); }
@Test public void testCast(){ assertEquals("hello", TypeUtil.cast(DataType.STRING, "hello")); assertEquals("12", TypeUtil.cast(DataType.STRING, 12)); assertEquals("true", TypeUtil.cast(DataType.STRING, true)); assertEquals(Integer.valueOf(10), TypeUtil.cast(DataType.INTEGER, "10")); assertEquals(Integer.valueOf(5), TypeUtil.cast(DataType.INTEGER, 5.3)); assertEquals(Integer.valueOf(-3), TypeUtil.cast(DataType.INTEGER, "-3")); assertEquals(Float.valueOf(10.0F), TypeUtil.cast(DataType.FLOAT, "10")); assertEquals(Float.valueOf(5.3F), TypeUtil.cast(DataType.FLOAT, 5.3)); assertEquals(Float.valueOf(-3.0F), TypeUtil.cast(DataType.FLOAT, "-3")); assertEquals(Double.valueOf(10.0), TypeUtil.cast(DataType.DOUBLE, "10")); assertEquals(Double.valueOf(5.3), TypeUtil.cast(DataType.DOUBLE, 5.3)); assertEquals(Double.valueOf(-3.0), TypeUtil.cast(DataType.DOUBLE, "-3")); assertEquals(Boolean.TRUE, TypeUtil.cast(DataType.BOOLEAN, "true")); assertEquals(Boolean.FALSE, TypeUtil.cast(DataType.BOOLEAN, "false")); assertEquals(Boolean.FALSE, TypeUtil.cast(DataType.BOOLEAN, null)); assertEquals(LocalDate.of(2021, 9, 22), TypeUtil.cast(DataType.DATE, "2021-09-22")); assertEquals(LocalDate.of(2000, 1, 2), TypeUtil.cast(DataType.DATE, "2000-01-02")); assertEquals(LocalDate.of(1970, 1, 1), TypeUtil.cast(DataType.DATE, "1970-01-01")); assertEquals(LocalTime.of(12, 0), TypeUtil.cast(DataType.TIME, "12:00:00")); assertEquals(LocalTime.of(6, 30), TypeUtil.cast(DataType.TIME, "6:30:00")); assertEquals(LocalTime.of(0, 0), TypeUtil.cast(DataType.TIME, "00:00:00")); assertEquals(LocalDateTime.of(2019, 12, 31, 23, 59, 59), TypeUtil.cast(DataType.DATE_TIME, "2019-12-31T23:59:59")); assertEquals(LocalDateTime.of(2021, 1, 1, 0, 0, 0), TypeUtil.cast(DataType.DATE_TIME, "2021-01-01T00:00:00")); assertEquals(LocalDateTime.of(1970, 1, 1, 0, 0, 0), TypeUtil.cast(DataType.DATE_TIME, "1970-01-01T00:00:00")); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); try { FieldValue result = FunctionUtil.evaluate(apply, values, context); fail("Expected UnsupportedFeatureException to be thrown"); } catch (UnsupportedFeatureException e) { } }
@Test public void testBinaryOr() { assertTrue(PredicateUtil.binaryOr(true, false)); assertTrue(PredicateUtil.binaryOr(false, true)); assertTrue(PredicateUtil.binaryOr(true, true)); assertFalse(PredicateUtil.binaryOr(false, false)); assertNull(PredicateUtil.binaryOr(false, null)); assertNull(PredicateUtil.binaryOr(null, false)); assertNull(PredicateUtil.binaryOr(null, null)); }
@Test public void evaluate_GivenValidApplyAndValues_ReturnsFieldValue() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue expected = new FieldValue("expected"); Function function = mock(Function.class); when(function.evaluate(values)).thenReturn(expected); when(getFunction("functionName")).thenReturn(function); FieldValue actual = FunctionUtil.evaluate(apply, values, context); assertEquals(expected, actual); verify(function).evaluate(values); verifyNoMoreInteractions(function); }
@Test public void testEvaluateNormDiscrete() { NormalizedField field = new NormalizedField(Normalize.unknown(), 10.0, 20.0, null, null); EvaluationContext context = new EvaluationContext(Collections.singletonMap("field", field)); NormDiscrete normDiscrete = new NormDiscrete("value1", Collections.singletonMap("unknown", 0.0), field); FieldValue result = ExpressionUtil.evaluateNormDiscrete(normDiscrete, context); assertEquals(result.getValueAsDouble(), 0.0); FieldValue value = new FieldValue("value1"); context = new EvaluationContext(Collections.singletonMap("field", value)); result = ExpressionUtil.evaluateNormDiscrete(normDiscrete, context); assertEquals(result.getValueAsDouble(), 1.0); }
@Test public void evaluate_shouldReturnCorrectFieldValue(){ Apply apply = new Apply("sum"); List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue(10)); values.add(new FieldValue(20)); EvaluationContext context = new EvaluationContext(); FieldValue expectedResult = new FieldValue(30); assertEquals(expectedResult, FunctionUtil.evaluate(apply, values, context)); }
@Test public void testGetValue() { SparseArray<Integer> sparseArray = new IntSparseArray<>(); sparseArray.put(5, 10); Integer expectedOutput = 10; Integer actualOutput = SparseArrayUtil.getValue(sparseArray, 5); assertEquals(expectedOutput, actualOutput); }
@Test public void testMarshal() { FieldName name = new FieldName("testName"); String marshalledValue = FieldName.marshal(name); assertEquals("testName", marshalledValue); FieldName nullName = null; String marshalledNullValue = FieldName.marshal(nullName); assertNull(marshalledNullValue); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("John", FieldType.STRING)); values.add(new FieldValue("Doe", FieldType.STRING)); Apply apply = new Apply("concat", values); EvaluationContext context = new EvaluationContext(); String expected = "JohnDoe"; FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(expected, result.getValue()); }
@Test public void testEvaluate(){ Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("arg1", "hello")); values.add(new FieldValue("arg2", 5)); EvaluationContext context = new EvaluationContext(new HashMap<String, DefineFunction>(), new HashMap<String, DefineVariable>()); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testPrepare() { DataField dataField = new DataField(DataType.DOUBLE); MiningField miningField = new MiningField("field"); miningField.setMissingValueReplacement(0.0); Object value = null; FieldValue fieldValue = ArgumentUtil.prepare(dataField, miningField, value); assertNull(fieldValue); value = "invalid"; try { ArgumentUtil.prepare(dataField, miningField, value); fail("Expected InvalidFeatureException"); } catch (InvalidFeatureException e) { } miningField.setOutlierTreatment(OutlierTreatmentMethodType.AS_EXTREME_VALUES); miningField.setLowValue(0.0); miningField.setHighValue(10.0); value = 20.0; fieldValue = ArgumentUtil.prepare(dataField, miningField, value); assertEquals(10.0, fieldValue.getValue()); value = "missing"; miningField.setInvalidValueTreatment(InvalidValueTreatmentMethodType.AS_MISSING); fieldValue = ArgumentUtil.prepare(dataField, miningField, value); assertEquals(0.0, fieldValue.getValue()); dataField = null; try { ArgumentUtil.prepare(dataField, miningField, value); fail("Expected InvalidFeatureException"); } catch (InvalidFeatureException e) { } }
@Test public void evaluateDiscretizeTest() { Discretize discretize = new Discretize(); EvaluationContext context = new EvaluationContext(); discretize.setField("field"); discretize.setMapMissingTo("missing"); discretize.setDataType(DataType.INTEGER); FieldValue fieldValue = FieldValueUtil.create(DataType.INTEGER, 5, discretize.getMapMissingTo()); when(ExpressionUtil.evaluate(discretize.getField(), context)).thenReturn(fieldValue); FieldValue expected = DiscretizationUtil.discretize(discretize, fieldValue); assertEquals(expected, ExpressionUtil.evaluateDiscretize(discretize, context)); }
@Test public void getDataType_ValidInput_ReturnsCorrectDataType(){ assertEquals(DataType.STRING, TypeUtil.getDataType("Hello")); assertEquals(DataType.INTEGER, TypeUtil.getDataType(25)); assertEquals(DataType.FLOAT, TypeUtil.getDataType(2.5f)); assertEquals(DataType.DOUBLE, TypeUtil.getDataType(3.14159)); assertEquals(DataType.BOOLEAN, TypeUtil.getDataType(true)); assertEquals(DataType.DATE, TypeUtil.getDataType(LocalDate.now())); assertEquals(DataType.TIME, TypeUtil.getDataType(LocalTime.now())); assertEquals(DataType.DATE_TIME, TypeUtil.getDataType(LocalDateTime.now())); assertEquals(DataType.DATE_DAYS_SINCE_1960, TypeUtil.getDataType(new DaysSinceDate(LocalDate.of(1960,1,1),10000))); assertEquals(DataType.DATE_DAYS_SINCE_1970, TypeUtil.getDataType(new DaysSinceDate(LocalDate.of(1970,1,1),10000))); assertEquals(DataType.DATE_DAYS_SINCE_1980, TypeUtil.getDataType(new DaysSinceDate(LocalDate.of(1980,1,1),10000))); assertEquals(DataType.TIME_SECONDS, TypeUtil.getDataType(new SecondsSinceMidnight(50000))); assertEquals(DataType.DATE_TIME_SECONDS_SINCE_1960, TypeUtil.getDataType(new SecondsSinceDate(LocalDate.of(1960,1,1),10000))); assertEquals(DataType.DATE_TIME_SECONDS_SINCE_1970, TypeUtil.getDataType(new SecondsSinceDate(LocalDate.of(1970,1,1),10000))); assertEquals(DataType.DATE_TIME_SECONDS_SINCE_1980, TypeUtil.getDataType(new SecondsSinceDate(LocalDate.of(1980,1,1),10000))); }
@Test public void evaluate_FunctionExist_ReturnsResult(){ EvaluationContext context = mock(EvaluationContext.class); Apply apply = mock(Apply.class); Function function = mock(Function.class); List<FieldValue> values = new ArrayList<>(); FieldValue fieldValue = mock(FieldValue.class); values.add(fieldValue); String name = "testName"; when(apply.getFunction()).thenReturn(name); when(getFunction(name)).thenReturn(function); when(function.evaluate(values)).thenReturn(fieldValue); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(result, fieldValue); }
@Test public void testAcceptable() { Double expected = 10.0; Double actual = 9.99999; Double precision = 0.001; Double zeroThreshold = 0.0001; boolean result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertFalse(result); expected = 10.0; actual = 10.0001; precision = 0.001; zeroThreshold = 0.0001; result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertFalse(result); expected = 0.0; actual = 0.0001; precision = 0.001; zeroThreshold = 0.0001; result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertFalse(result); actual = null; precision = 0.001; zeroThreshold = 0.0001; result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertFalse(result); expected = null; actual = null; precision = 0.001; zeroThreshold = 0.0001; result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertTrue(result); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("String", "Hello")); values.add(new FieldValue("Integer", 5)); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("myFunction"); try { FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(UnsupportedFeatureException.class, result.getClass()); } catch (Exception e) { fail("Unexpected exception thrown"); } }
@Test public void testEvaluateFieldRef() { FieldRef fieldRef = new FieldRef("fieldName", "mapMissingTo"); EvaluationContext context = new EvaluationContext(); context.setFieldValue("fieldName", new FieldValue("fieldValue")); FieldValue result = ExpressionUtil.evaluateFieldRef(fieldRef, context); Assert.assertEquals(new FieldValue("fieldValue"), result); context.setFieldValue("fieldName", null); result = ExpressionUtil.evaluateFieldRef(fieldRef, context); Assert.assertEquals(new FieldValue("mapMissingTo"), result); }
@Test public void testIsInvalid(){ DataField df = new DataField(); df.setName("testField"); df.setType("INTEGER"); Integer value = 5; assertFalse(ArgumentUtil.isInvalid(df, value)); value = null; assertTrue(ArgumentUtil.isInvalid(df, value)); }
@Test public void testGetConstantDataType() { assertEquals(DataType.FLOAT, TypeUtil.getConstantDataType("3.14159")); assertEquals(DataType.INTEGER, TypeUtil.getConstantDataType("42")); assertEquals(DataType.STRING, TypeUtil.getConstantDataType("Hello, world!")); }
@Test public void testEvaluate(){ List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("apple")); values.add(new FieldValue("banana")); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("sum"); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(null, result); apply = new Apply("concat"); result = FunctionUtil.evaluate(apply, values, context); assertEquals("applebanana", result.getValue()); }
@Test public void testBinaryAnd() { assertTrue(PredicateUtil.binaryAnd(true, true)); assertFalse(PredicateUtil.binaryAnd(true, false)); assertFalse(PredicateUtil.binaryAnd(false, true)); assertFalse(PredicateUtil.binaryAnd(false, false)); assertNull(PredicateUtil.binaryAnd(true, null)); assertNull(PredicateUtil.binaryAnd(false, null)); assertNull(PredicateUtil.binaryAnd(null, true)); assertNull(PredicateUtil.binaryAnd(null, false)); assertNull(PredicateUtil.binaryAnd(null, null)); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("testValue1")); values.add(new FieldValue("testValue2")); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("testFunction"); FunctionUtil.evaluate(apply, values, context); }
@Test public void testCreate() { FieldName field = FieldName.create("Test"); assertEquals("Test", field.toString()); }
@Test public void testContains() { Interval interval = new Interval(1.0, 5.0, Interval.Closure.CLOSED_CLOSED); assertTrue(DiscretizationUtil.contains(interval, 1.0)); assertTrue(DiscretizationUtil.contains(interval, 5.0)); assertTrue(DiscretizationUtil.contains(interval, 3.0)); assertFalse(DiscretizationUtil.contains(interval, 0.9)); assertFalse(DiscretizationUtil.contains(interval, 5.1)); }
@Test public void evaluate_FunctionExists_EvaluatesFunction() { Apply apply = new Apply("functionName"); List<FieldValue> values = Arrays.asList(new FieldValue("value1"), new FieldValue("value2")); EvaluationContext context = new EvaluationContext(); Function function = mock(Function.class); when(function.evaluate(values)).thenReturn(new FieldValue("result")); FunctionUtil.setFunction("functionName", function); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); assertEquals("result", result.getValue()); verify(function, times(1)).evaluate(values); }
@Test public void testEvaluateAggregate() { Field field = new Field("exampleField"); FieldName groupName = new FieldName("exampleGroup"); Aggregate aggregate = new Aggregate(field, groupName, Aggregate.Function.AVERAGE); EvaluationContext context = new EvaluationContext(); FieldValue value1 = FieldValueUtil.create(3); FieldValue value2 = FieldValueUtil.create(5); FieldValue value3 = FieldValueUtil.create(null); Collection<?> values = Arrays.asList(value1, value2, value3); context.setFieldValue(field, FieldValueUtil.create(values)); context.setFieldValue(groupName, FieldValueUtil.create("exampleGroupValue")); FieldValue result = ExpressionUtil.evaluateAggregate(aggregate, context); assertEquals(4, FieldValueUtil.getValue(result)); }
@Test public void testGroupRows() { Map<String, Object> row1 = new HashMap<>(); row1.put("Name", "Alice"); row1.put("Age", 25); row1.put("Gender", "Female"); Map<String, Object> row2 = new HashMap<>(); row2.put("Name", "Bob"); row2.put("Age", 23); row2.put("Gender", "Male"); Map<String, Object> row3 = new HashMap<>(); row3.put("Name", "Charlie"); row3.put("Age", 25); row3.put("Gender", "Male"); List<Map<String, Object>> table = new ArrayList<>(); table.add(row1); table.add(row2); table.add(row3); List<Map<String, Object>> groupedTable = EvaluatorUtil.groupRows("Age", table); assertEquals(2, groupedTable.size()); Map<String, Object> group1 = groupedTable.get(0); assertEquals(25, group1.get("Age")); assertEquals(2, group1.size()); Map<String, Object> group2 = groupedTable.get(1); assertEquals(23, group2.get("Age")); assertEquals(1, group2.size()); }
@Test public void testCreate(){ FieldName fieldName = FieldName.create("testValue"); assertNotNull(fieldName); }
@Test public void testIsValid() { DataField df = new DataField(); df.setDataType(DataType.STRING); df.setOptype(OpType.CATEGORICAL); List<Value> values = new ArrayList<>(); values.add(new Value("apple", Value.Property.VALID)); values.add(new Value("orange", Value.Property.VALID)); df.setValues(values); assertTrue(ArgumentUtil.isValid(df, "apple")); assertFalse(ArgumentUtil.isValid(df, "banana")); }
@Test public void testProcess(){ Target target = new Target(); target.setMin(0.0); target.setMax(100.0); target.setRescaleFactor(2.0); target.setRescaleConstant(10.0); Number result = TargetUtil.process(target, 50.0); assertEquals(120.0, result); }
@Test public void testChangedLinesComputer() { ChangedLinesComputer clc = new ChangedLinesComputer(tracker); Set<Integer> expected = new HashSet<Integer>(); expected.add(1); expected.add(2); expected.add(3); tracker.addChangedLine(1); tracker.addChangedLine(2); tracker.addChangedLine(3); Set<Integer> actual = clc.changedLines(); assertEquals(expected, actual); }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("/path/to/project"); Instant forkDate = gitScmProvider.forkDate("referenceBranchName", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(5); expected.add(10); expected.add(15); assertEquals(expected, clc.changedLines()); }
@Test public void testBranchChangedLines() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); String targetBranchName = "test-branch"; Path projectBaseDir = Paths.get("/path/to/project"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("src/main/java/com/example/MyClass.java")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertTrue(result.containsKey(Paths.get("src/main/java/com/example/MyClass.java"))); }
@Test public void testBlameCommand() { PathResolver pathResolver = new DefaultPathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("/path/to/repo")); Spliterator<InputFile> spliterator = Spliterators.spliterator(new ArrayList<InputFile>().iterator(), 0, 0); when(input.filesToBlame()).thenReturn(spliterator); jgitBlameCommand.blame(input, output); }
@Test public void testBranchChangedFiles() throws IOException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path newFile = tempDir.resolve("newFile.txt"); Files.createFile(newFile); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Files.write(newFile, "Hello, world!".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); Set<Path> expectedSet = new HashSet<>(); expectedSet.add(newFile); assertEquals(expectedSet, changedFiles); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBlame() throws Exception { BlameInput input = Mockito.mock(BlameInput.class); Mockito.when(input.fileSystem().baseDir()).thenReturn(new File(".")); Mockito.when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("file1"), new InputFile("file2"))); BlameOutput output = Mockito.mock(BlameOutput.class); JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(Mockito.mock(PathResolver.class), Mockito.mock(AnalysisWarnings.class)); jgitBlameCommand.blame(input, output); Mockito.verify(output, Mockito.times(2)).blameResultPerFile(Mockito.any()); }
@Test public void testBranchChangedLines() throws Exception { JGitBlameCommand jGitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Path file1 = Files.createFile(tempDir.resolve("file1.txt")); Files.write(file1, Arrays.asList("Hello", "World")); Path file2 = Files.createFile(tempDir.resolve("file2.txt")); Files.write(file2, Arrays.asList("This is", "a test")); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(file1, Arrays.asList("Hello", "Everyone")); git.checkout().setName("testBranch").call(); git.add().addFilepattern(".").call(); git.commit().setMessage("New commit").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(file1); GitScmProvider gitScmProvider = new GitScmProvider(jGitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(result.size(), 1); assertTrue(result.containsKey(file1)); assertEquals(result.get(file1), new HashSet<>(Arrays.asList(2))); }
@Test public void testBranchChangedFiles() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expectedFiles = new HashSet<>(); expectedFiles.add(Paths.get("path/to/added/file")); expectedFiles.add(Paths.get("path/to/modified/file")); Set<Path> actualFiles = gitScmProvider.branchChangedFiles("target-branch", rootBaseDir); assertEquals(expectedFiles, actualFiles); }
@Test public void testChangedLines() { Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(4); Tracker tracker = new Tracker(); tracker.setChangedLines(expected); ChangedLinesComputer computer = new ChangedLinesComputer(tracker); Set<Integer> actual = computer.changedLines(); assertEquals(expected, actual); }
@Test public void testForkDate() throws Exception { Path tempDir = Files.createTempDirectory("testGitRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Git git = Git.open(tempDir.toFile()); git.branchCreate().setName("testBranch").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Instant forkDate = gitScmProvider.forkDate("testBranch", tempDir); assertNotNull(forkDate); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testForkDate() throws IOException { Path projectBaseDir = Paths.get("path/to/project/dir"); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Instant instant = gitScmProvider.forkDate("main", projectBaseDir); assertNull(instant); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(Mockito.mock(JGitBlameCommand.class), Mockito.mock(AnalysisWarnings.class), Mockito.mock(GitIgnoreCommand.class), Mockito.mock(System2.class)); Path baseDir = Files.createTempDirectory("test"); File file1 = new File(baseDir.toFile(), "file1.java"); File file2 = new File(baseDir.toFile(), "file2.java"); Files.write(file1.toPath(), "content".getBytes()); Files.write(file2.toPath(), "content".getBytes()); gitScmProvider.initRepo(baseDir.toPath()); gitScmProvider.setGlobalConfig(baseDir.toPath()); gitScmProvider.commit("Initial commit"); Files.write(file1.toPath(), "modified".getBytes()); gitScmProvider.commit("Modified file1"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("HEAD", baseDir); Assert.assertEquals(1, changedFiles.size()); Assert.assertTrue(changedFiles.contains(file1.toPath().toAbsolutePath().normalize())); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitProvider = new GitScmProvider(mock(JGitBlameCommand.class), mock(AnalysisWarnings.class), mock(GitIgnoreCommand.class), mock(System2.class)); Set<Path> expected = new HashSet<>(Arrays.asList(Paths.get("src/main/java/com/example/MyClass.java"), Paths.get("src/test/java/com/example/MyClassTest.java"))); Set<Path> actual = gitProvider.branchChangedFiles("develop", Paths.get("/path/to/root/dir")); assertEquals(expected, actual); }
@Test public void testBlame() throws IOException { PathResolver pathResolver = new PathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(null); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); BlameInput input = Mockito.mock(BlameInput.class); when(input.fileSystem().baseDir()).thenReturn(new File("path/to/repo")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("path/to/repo/file1"), new InputFile("path/to/repo/file2"))); BlameOutput output = Mockito.mock(BlameOutput.class); jGitBlameCommand.blame(input, output); }
@Test public void testBlameCommand() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); assertSame(jgitBlameCommand, gitScmProvider.blameCommand()); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("/path/to/project/src/file.java"); Path expectedRelativePath = Paths.get("src/file.java"); assertEquals(expectedRelativePath, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testBranchChangedLines() throws Exception { File testRepoDir = temporaryFolder.newFolder("testRepo"); Git.init().setDirectory(testRepoDir).call(); Path filePath = Paths.get(testRepoDir.getPath(), "testfile"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(testRepoDir); git.add().addFilepattern(".").call(); git.commit().setMessage("initial commit").call(); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines("master", testRepoDir.toPath(), Collections.singleton(filePath)); assertEquals(1, result.keySet().size()); Set<Integer> lineNumbers = result.get(filePath); assertFalse(lineNumbers.isEmpty()); }
@Test public void testBlame() throws IOException { File file = new File("testfile.txt"); FileWriter writer = new FileWriter(file); writer.write("This is a test file"); writer.close(); PathResolver pathResolver = new PathResolver(); AnalysisWarnings warnings = new AnalysisWarnings(); BlameInput input = new BlameInput(new DefaultFileSystem(), Collections.singleton(file.toPath())); BlameOutput output = new BlameOutput(); JGitBlameCommand command = new JGitBlameCommand(pathResolver, warnings); command.blame(input, output); List<BlameLine> lines = output.result().get(file.toPath()); assertEquals(1, lines.size()); assertEquals("This is a test file", lines.get(0).getContent()); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); File file = new File("path/to/file.txt"); InputFile inputFile = mock(InputFile.class); when(inputFile.toString()).thenReturn(file.toString()); when(input.filesToBlame()).thenReturn(Collections.singletonList(inputFile)); when(input.fileSystem()).thenReturn(mock(FileSystem.class)); when(input.fileSystem().baseDir()).thenReturn(new File("path/to")); BlameOutput output = mock(BlameOutput.class); JGitBlameCommand command = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); command.blame(input, output); verify(output).blameResult(file.toString(), Collections.emptyList()); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Set<Path> result = gitScmProvider.branchChangedFiles("master", Paths.get("path/to/rootBaseDir")); assertNotNull(result); }
@Test public void testGitScmProviderKey() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Assert.assertEquals("git", gitScmProvider.key()); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); Git.init().setDirectory(tempDir.toFile()).call(); Path initialFile = tempDir.resolve("file.txt"); Files.createFile(initialFile); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFile = tempDir.resolve("newFile.txt"); Files.createFile(newFile); git.add().addFilepattern(".").call(); git.commit().setMessage("Added new file").call(); GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Set<Path> changedFiles = provider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFile)); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider scmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path", "to", "root", "dir"); Set<Path> expectedPaths = new HashSet<>(Arrays.asList( rootBaseDir.resolve("file1.txt"), rootBaseDir.resolve("dir1").resolve("file2.txt"), rootBaseDir.resolve("dir2").resolve("file3.txt") )); Set<Path> actualPaths = scmProvider.branchChangedFiles("master", rootBaseDir); assertEquals(expectedPaths, actualPaths); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { git.branchCreate().setName("testBranch").call(); File file = Paths.get(tempDir.toString(), "testFile.txt").toFile(); FileUtils.writeStringToFile(file, "content", Charset.defaultCharset()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setName("testBranch").call(); FileUtils.writeStringToFile(file, "newContent", Charset.defaultCharset()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); Set<Path> expectedFiles = new HashSet<>(); expectedFiles.add(Paths.get(tempDir.toString(), "testFile.txt")); Assert.assertEquals(expectedFiles, changedFiles); } FileUtils.deleteDirectory(tempDir.toFile()); }
@Test public void testBranchChangedLines() throws Exception { Path projectBaseDir = Files.createTempDirectory("testProjectBaseDir"); Path changedFile = projectBaseDir.resolve("dummyFile.txt"); Files.write(changedFile, "Some content".getBytes(StandardCharsets.UTF_8)); String targetBranchName = "main"; GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, Set.of(changedFile)); assertNotNull(result); }
@Test public void testSupports() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); File baseDir = new File("path/to/git/repo"); assertTrue(gitScmProvider.supports(baseDir)); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Path rootBaseDir = Paths.get(System.getProperty("user.dir")); String targetBranchName = "master"; Set expectedSet = new HashSet<>(); expectedSet.add(rootBaseDir.resolve("file1.txt")); expectedSet.add(rootBaseDir.resolve("file2.txt")); Set actualSet = provider.branchChangedFiles(targetBranchName, rootBaseDir); assertEquals(expectedSet, actualSet); }
@Test public void testGitThreadFactoryNewThread() { ForkJoinPool pool = new ForkJoinPool(); GitThreadFactory factory = new GitThreadFactory(); ForkJoinWorkerThread thread = factory.newThread(pool); assertNotNull(thread); assertEquals("GitThreadFactory-0", thread.getName()); }
@Test public void testBranchChangedLines() throws Exception { Path baseDir = Paths.get("path/to/project/base/dir"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("path/to/file1")); changedFiles.add(Paths.get("path/to/file2")); JGitBlameCommand jGitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jGitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines("master", baseDir, changedFiles); assertNotNull(result); assertFalse(result.isEmpty()); }
@Test public void testBranchChangedLines() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/projectBaseDir"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("path/to/changedFile1")); changedFiles.add(Paths.get("path/to/changedFile2")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines("targetBranchName", projectBaseDir, changedFiles); assertNotNull(result); assertTrue(result.containsKey(Paths.get("path/to/changedFile1"))); assertTrue(result.containsKey(Paths.get("path/to/changedFile2"))); assertFalse(result.get(Paths.get("path/to/changedFile1")).isEmpty()); assertFalse(result.get(Paths.get("path/to/changedFile2")).isEmpty()); }
@Test public void testDefine() { GitPlugin gitPlugin = new GitPlugin(); Context context = mock(Context.class); JGitBlameCommand jGitBlameCommand = mock(JGitBlameCommand.class); GitScmProvider gitScmProvider = mock(GitScmProvider.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); gitPlugin.define(context); verify(context).addExtensions(jGitBlameCommand.getClass(), gitScmProvider.getClass(), gitIgnoreCommand.getClass()); assertTrue(FS.isAsyncFileStoreAttributes()); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider scmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Set<Path> expectedChangedFiles = new HashSet<>(Arrays.asList(Paths.get("file1.txt"), Paths.get("file2.txt"))); Set<Path> actualChangedFiles = scmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertEquals(expectedChangedFiles, actualChangedFiles); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); FileSystem fs = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fs); when(fs.baseDir()).thenReturn(new File("path/to/repo")); List<InputFile> filesToBlame = new ArrayList<>(); filesToBlame.add(mock(InputFile.class)); when(input.filesToBlame()).thenReturn(filesToBlame); BlameOutput output = mock(BlameOutput.class); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); jGitBlameCommand.blame(input, output); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("dir1", "dir2", "file.txt"); Path expectedRelativePath = Paths.get("..", "file.txt"); Path actualRelativePath = gitScmProvider.relativePathFromScmRoot(path); assertEquals(expectedRelativePath, actualRelativePath); }
@Test public void testBranchChangedFiles() throws Exception { Path tempDir = Files.createTempDirectory("test"); Path file1 = Files.createFile(tempDir.resolve("file1")); Path file2 = Files.createFile(tempDir.resolve("file2")); Path file3 = Files.createFile(tempDir.resolve("file3")); try (Repository repo = getRepository(tempDir)) { Git git = new Git(repo); git.add() .addFilepattern(".") .call(); git.commit() .setMessage("Initial commit") .call(); git.branchCreate() .setName("test-branch") .call(); Files.delete(file2); Files.write(file1, "content".getBytes(), StandardOpenOption.APPEND); Files.write(file3, "new content".getBytes(), StandardOpenOption.TRUNCATE_EXISTING); git.add() .addFilepattern(".") .call(); git.commit() .setMessage("Second commit") .call(); GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Set<Path> changedFiles = provider.branchChangedFiles("test-branch", tempDir); assertEquals(2, changedFiles.size()); assertTrue(changedFiles.contains(file1)); assertTrue(changedFiles.contains(file3)); } } private Path getRepository(Path directory) throws Exception { Git.init().setDirectory(directory.toFile()).call(); return new File(directory.toFile(), ".git").toPath(); }
@Test public void testBranchChangedLines() throws Exception { Path projectBaseDir = Paths.get("path/to/project/dir"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("path/to/changed/file1")); changedFiles.add(Paths.get("path/to/changed/file2")); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); JGitBlameCommand jGitBlameCommand = mock(JGitBlameCommand.class); System2 system2 = mock(System2.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitScmProvider gitScmProvider = new GitScmProvider(jGitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines("targetBranch", projectBaseDir, changedFiles); assertNotNull(result); assertTrue(result.containsKey(Paths.get("path/to/changed/file1"))); assertTrue(result.containsKey(Paths.get("path/to/changed/file2"))); }
@Test public void shouldReturnForkDateWhenTargetRefExistsAndDiffAlgoIsValid() throws Exception { Path projectBaseDir = Paths.get("/some/path/to-project"); String referenceBranchName = "some-branch-name"; GitScmProvider gitScmProvider = new GitScmProvider(mock(JGitBlameCommand.class), mock(AnalysisWarnings.class), mock(GitIgnoreCommand.class), mock(System2.class)); Repository repo = mock(Repository.class); Ref targetRef = mock(Ref.class); Config config = mock(Config.class); ValueHolder<Boolean> isDiffAlgoInvalid = new ValueHolder<>(false); RevCommit mergeBaseCommit = mock(RevCommit.class); Instant expectedInstant = Instant.now(); when(gitScmProvider.buildRepo(projectBaseDir)).thenReturn(repo); when(gitScmProvider.resolveTargetRef(referenceBranchName, repo)).thenReturn(targetRef); when(targetRef.getName()).thenReturn(referenceBranchName); when(gitScmProvider.isDiffAlgoInvalid(config)).thenReturn(isDiffAlgoInvalid); when(gitScmProvider.findMergeBase(repo, targetRef)).thenReturn(Optional.of(mergeBaseCommit)); when(mergeBaseCommit.getCommitTime()).thenReturn(expectedInstant.getEpochSecond()); Instant forkDate = gitScmProvider.forkDate(referenceBranchName, projectBaseDir); assertThat(forkDate, equalTo(expectedInstant)); }
@Test public void testChangedLines() { Tracker tracker = new Tracker(); tracker.addLine("first line"); tracker.addLine("second line"); tracker.addLine("third line"); tracker.removeLine("second line"); ChangedLinesComputer changedLinesComputer = new ChangedLinesComputer(tracker); Set<Integer> expectedSet = new HashSet<>(); expectedSet.add(1); expectedSet.add(3); assertEquals(expectedSet, changedLinesComputer.changedLines()); }
@Test public void testRelativePathFromScmRoot() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(mock(JGitBlameCommand.class), mock(AnalysisWarnings.class), mock(GitIgnoreCommand.class), mock(System2.class)); Path path = Paths.get("C:\\Users\\user\\git\\example-project\\src\\main\\java\\com\\example\\App.java"); Path expectedPath = Paths.get("src\\main\\java\\com\\example\\App.java"); assertEquals(expectedPath, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testRevisionId() { Path path = Paths.get("path/to/repo"); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); String result = gitScmProvider.revisionId(path); assertNotNull(result); }
@Test public void testBranchChangedFiles() throws Exception { Path rootBaseDir = Files.createTempDirectory("testDir"); Path testFile = Files.createFile(rootBaseDir.resolve("testFile.txt")); Files.write(testFile, "test content".getBytes()); Git.init().setDirectory(rootBaseDir.toFile()).call(); Git git = Git.open(rootBaseDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("newBranch").call(); Files.write(testFile, "modified test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified test file").call(); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("newBranch", rootBaseDir); assertTrue(changedFiles.contains(testFile)); FileUtils.deleteDirectory(rootBaseDir.toFile()); }
@Test public void testBlame() { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fs = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fs); when(fs.baseDir()).thenReturn(new File("path/to/repo")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("path/to/file"))); JGitBlameCommand command = new JGitBlameCommand(new PathResolver(), new AnalysisWarnings()); command.blame(input, output); verify(output, times(1)).blameResult(any(BlameResult.class)); }
@Test public void testBranchChangedLines() throws Exception { Set<Path> changedFiles = new HashSet<>(); Path projectBaseDir = Paths.get("/path/to/project"); String targetBranchName = "master"; GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertFalse(result.isEmpty()); }
@Test public void testForkDate() throws Exception { GitScmProvider provider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path projectBaseDir = Paths.get("/path/to/base/dir"); Instant forkDate = provider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLinesComputer() { ChangedLinesComputer clc = new ChangedLinesComputer(tracker); Set<Integer> expectedResult = new HashSet<>(); expectedResult.add(10); expectedResult.add(20); expectedResult.add(30); assertEquals(expectedResult, clc.changedLines()); }
@Test public void testBlame() throws Exception { PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); BlameCommand.BlameInput input = mock(BlameCommand.BlameInput.class); BlameCommand.BlameOutput output = mock(BlameCommand.BlameOutput.class); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(input, atLeastOnce()).fileSystem(); verify(input, atLeastOnce()).filesToBlame(); verify(output, atLeastOnce()).output(any()); }
@Test public void testBranchChangedFiles() throws Exception { String targetBranchName = "test-branch"; Path rootBaseDir = Paths.get("/path/to/root/dir"); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Set<Path> files = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(files); }