@Test public void testExecute() throws Exception { RosetteApiWrapper rosAPI = new RosetteApiWrapper("apiKey"); String tag = "testTag"; String description = "testDescription"; String processorType = "testProcessorType"; String inputField = "testInputField"; String targetField = "testTargetField"; RosetteAbstractProcessor processor = new RosetteAbstractProcessor(rosAPI, tag, description, processorType, inputField, targetField); IngestDocument ingestDocument = new IngestDocument("testId", "testType"); ingestDocument.setFieldValue(inputField, "This is a test input text."); IngestDocument result = processor.execute(ingestDocument); assertNotNull(result); assertFalse(result.hasField(targetField)); assertEquals("This is a test input text.", result.getFieldValue(inputField, String.class)); }
@Test public void testFormatToUserFriendlyFormat() { Date date = new Date(); String expected = DateFormat.getDateInstance(DateFormat.FULL).format(date); String actual = DateHelper.formatToUserFriendlyFormat(date); assertEquals(expected, actual); }
@Test public void testHasDescription() { UiLesson uiLesson = new UiLesson(); uiLesson.setDescription("This is a lesson description."); assertTrue(uiLesson.hasDescription()); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0, 100); FieldValue value = FieldValueUtil.create(50); FieldValue normalizedValue = NormalizationUtil.normalize(normContinuous, value); double expectedValue = 0.5; double delta = 0.0001; assertEquals(expectedValue, normalizedValue.asNumber().doubleValue(), delta); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil.evaluate(apply, values, context); }
@Test public void testGetResultDataType() { DataType left = DataType.INTEGER; DataType right = DataType.DOUBLE; DataType expected = DataType.NUMERIC; assertEquals(expected, TypeUtil.getResultDataType(left, right)); }
@Test public void testDenormalize() { NormContinuous normContinuous = new NormContinuous(); List<LinearNorm> linearNorms = new ArrayList<>(); linearNorms.add(new LinearNorm(0, 0)); linearNorms.add(new LinearNorm(1, 1)); normContinuous.setLinearNorms(linearNorms); double value = 0.5; double expected = 0.5; double result = NormalizationUtil.denormalize(normContinuous, value); assertEquals(expected, result, 0.0001); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "name", "John"); table.put(1, "age", "30"); table.put(2, "name", "Jane"); table.put(2, "age", "25"); Map<String, FieldValue> values = new HashMap<>(); values.put("name", new FieldValue("John")); values.put("age", new FieldValue("30")); Map<String, String> expected = table.row(1); Map<String, String> actual = InlineTableUtil.match(table, values); assertEquals(expected, actual); }
@Test public void testIsZero() { assertTrue(VerificationUtil.isZero(0, 0.0001)); assertTrue(VerificationUtil.isZero(0.0, 0.0001)); assertTrue(VerificationUtil.isZero(0.00009, 0.0001)); assertFalse(VerificationUtil.isZero(0.00011, 0.0001)); assertFalse(VerificationUtil.isZero(1, 0.0001)); assertFalse(VerificationUtil.isZero(-1, 0.0001)); }
@Test public void testEvaluateConstant() { Constant constant = new Constant("test", DataType.STRING); EvaluationContext context = new EvaluationContext(); FieldValue result = ExpressionUtil.evaluateConstant(constant, context); assertEquals(DataType.STRING, result.getDataType()); assertEquals("test", result.getValue()); }
@Test public void testUnmarshal() { FieldName name1 = new FieldName("test"); FieldName name2 = FieldName.unmarshal("test"); assertEquals(name1, name2); }
@Test public void testEvaluateSimilarity() { ComparisonMeasure comparisonMeasure = new ComparisonMeasure(new SimpleMatching()); List<ComparisonField> comparisonFields = new ArrayList<>(); comparisonFields.add(new ComparisonField("field1")); comparisonFields.add(new ComparisonField("field2")); comparisonFields.add(new ComparisonField("field3")); BitSet flags = new BitSet(); flags.set(0); flags.set(2); BitSet referenceFlags = new BitSet(); referenceFlags.set(0); referenceFlags.set(1); Double result = MeasureUtil.evaluateSimilarity(comparisonMeasure, comparisonFields, flags, referenceFlags); assertEquals(0.5, result, 0.001); }
@Test public void testParse() { assertEquals("hello", TypeUtil.parse(DataType.STRING, "hello")); assertEquals(123, TypeUtil.parse(DataType.INTEGER, "123")); assertEquals(3.14f, TypeUtil.parse(DataType.FLOAT, "3.14"), 0.001); assertEquals(2.71828, TypeUtil.parse(DataType.DOUBLE, "2.71828"), 0.00001); assertTrue((boolean) TypeUtil.parse(DataType.BOOLEAN, "true")); assertFalse((boolean) TypeUtil.parse(DataType.BOOLEAN, "false")); assertEquals(LocalDate.of(2021, 10, 31), TypeUtil.parse(DataType.DATE, "2021-10-31")); assertEquals(LocalTime.of(12, 30, 45), TypeUtil.parse(DataType.TIME, "12:30:45")); assertEquals(LocalDateTime.of(2021, 10, 31, 12, 30, 45), TypeUtil.parse(DataType.DATE_TIME, "2021-10-31T12:30:45")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1960, LocalDate.of(2021, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1960, "18923")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1970, LocalDate.of(2021, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1970, "18923")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1980, LocalDate.of(2021, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1980, "18923")); assertEquals(new SecondsSinceMidnight(45045), TypeUtil.parse(DataType.TIME_SECONDS, "12:30:45")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1960, LocalDateTime.of(2021, 10, 31, 12, 30, 45)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1960, "1646145045")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1970, LocalDateTime.of(2021, 10, 31, 12, 30, 45)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1970, "1635694245")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1980, LocalDateTime.of(2021, 10, 31, 12, 30, 45)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1980, "1577667045")); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil.evaluate(apply, values, context); }
@Test public void testBinaryXor() { assertTrue(PredicateUtil.binaryXor(true, false)); assertTrue(PredicateUtil.binaryXor(false, true)); assertFalse(PredicateUtil.binaryXor(true, true)); assertFalse(PredicateUtil.binaryXor(false, false)); assertNull(PredicateUtil.binaryXor(true, null)); assertNull(PredicateUtil.binaryXor(null, false)); assertNull(PredicateUtil.binaryXor(null, null)); }
@Test public void testDecodeComputable() { Computable computable = new Computable() { @Override public Object getResult() { return "result"; } }; Object result = EvaluatorUtil.decode(computable); assertEquals("result", result); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil.evaluate(apply, values, context); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "name", "John"); table.put(1, "age", "30"); table.put(2, "name", "Jane"); table.put(2, "age", "25"); Map<String, FieldValue> values = new HashMap<>(); values.put("name", new FieldValue("John")); values.put("age", new FieldValue("30")); Map<String, String> expected = table.row(1); Map<String, String> actual = InlineTableUtil.match(table, values); assertEquals(expected, actual); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateMapValues() { MapValues mapValues = new MapValues(DataType.STRING, "missing"); mapValues.addFieldColumnPair(new FieldColumnPair("field1", "column1")); mapValues.addFieldColumnPair(new FieldColumnPair("field2", "column2")); EvaluationContext context = new EvaluationContext(); context.setFieldValue("field1", new FieldValue("value1")); context.setFieldValue("field2", new FieldValue("value2")); FieldValue result = ExpressionUtil.evaluateMapValues(mapValues, context); Map<String, FieldValue> expectedValues = new LinkedHashMap<>(); expectedValues.put("column1", new FieldValue("value1")); expectedValues.put("column2", new FieldValue("value2")); FieldValue expected = DiscretizationUtil.mapValue(mapValues, expectedValues); assertEquals(expected, result); }
@Test public void testEvaluateNormContinuous() { NormContinuous normContinuous = new NormContinuous(); normContinuous.setField("field"); normContinuous.setMapMissingTo(0.0); EvaluationContext context = new EvaluationContext(); context.setFieldValue("field", FieldValueUtil.create(10.0)); FieldValue result = ExpressionUtil.evaluateNormContinuous(normContinuous, context); assertEquals(1.0, result.asDouble(), 0.001); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0, 100); FieldValue value = FieldValueUtil.create(50); FieldValue normalizedValue = NormalizationUtil.normalize(normContinuous, value); double expectedValue = 0.5; double delta = 0.0001; assertEquals(expectedValue, normalizedValue.asNumber().doubleValue(), delta); }
@Test public void testCast() { Object value = "123"; assertEquals("123", TypeUtil.cast(DataType.STRING, value)); value = 123; assertEquals(123, TypeUtil.cast(DataType.INTEGER, value)); value = 1.23f; assertEquals(1.23f, TypeUtil.cast(DataType.FLOAT, value)); value = 1.23; assertEquals(1.23, TypeUtil.cast(DataType.DOUBLE, value)); value = true; assertEquals(true, TypeUtil.cast(DataType.BOOLEAN, value)); value = "2021-10-01"; assertEquals(LocalDate.parse("2021-10-01"), TypeUtil.cast(DataType.DATE, value)); value = "10:30:00"; assertEquals(LocalTime.parse("10:30:00"), TypeUtil.cast(DataType.TIME, value)); value = "2021-10-01T10:30:00"; assertEquals(LocalDateTime.parse("2021-10-01T10:30:00"), TypeUtil.cast(DataType.DATE_TIME, value)); value = 18830; assertEquals(LocalDate.of(2021, 10, 1), TypeUtil.cast(DataType.DATE_DAYS_SINCE_1960, value)); value = 18830; assertEquals(LocalDate.of(1970, 1, 1), TypeUtil.cast(DataType.DATE_DAYS_SINCE_1970, value)); value = 18830; assertEquals(LocalDate.of(1980, 1, 1), TypeUtil.cast(DataType.DATE_DAYS_SINCE_1980, value)); value = 37800; assertEquals(LocalTime.of(10, 30, 00), TypeUtil.cast(DataType.TIME_SECONDS, value)); value = 18830 * 86400 + 37800; assertEquals(LocalDateTime.of(2021, 10, 1, 10, 30, 00), TypeUtil.cast(DataType.DATE_TIME_SECONDS_SINCE_1960, value)); value = 1601519400; assertEquals(LocalDateTime.of(2020, 10, 1, 10, 30, 00), TypeUtil.cast(DataType.DATE_TIME_SECONDS_SINCE_1970, value)); value = 315532800; assertEquals(LocalDateTime.of(1980, 1, 1, 0, 0, 00), TypeUtil.cast(DataType.DATE_TIME_SECONDS_SINCE_1980, value)); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testBinaryOr() { assertTrue(PredicateUtil.binaryOr(true, true)); assertTrue(PredicateUtil.binaryOr(true, false)); assertTrue(PredicateUtil.binaryOr(false, true)); assertFalse(PredicateUtil.binaryOr(false, false)); assertNull(PredicateUtil.binaryOr(null, true)); assertNull(PredicateUtil.binaryOr(true, null)); assertNull(PredicateUtil.binaryOr(null, null)); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateNormDiscrete() { NormDiscrete normDiscrete = new NormDiscrete("field", "value", 1.0); EvaluationContext context = new EvaluationContext(); context.setFieldValue("field", FieldValueUtil.create("value")); FieldValue result = ExpressionUtil.evaluateNormDiscrete(normDiscrete, context); assertEquals(1.0, result.getValue()); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testGetValue() { SparseArray<Integer> sparseArray = new IntSparseArray(); sparseArray.put(0, 10); sparseArray.put(2, 20); sparseArray.put(4, 30); Integer value = SparseArrayUtil.getValue(sparseArray, 2); assertEquals(Integer.valueOf(20), value); }
@Test public void testMarshal() { FieldName fieldName = new FieldName("test"); String marshalledFieldName = FieldName.marshal(fieldName); assertNotNull(marshalledFieldName); assertEquals("test", marshalledFieldName); FieldName nullFieldName = null; String marshalledNullFieldName = FieldName.marshal(nullFieldName); assertNull(marshalledNullFieldName); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil.evaluate(apply, values, context); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testPrepare() { DataField dataField = new DataField("testField", DataType.DOUBLE); MiningField miningField = new MiningField("testMiningField"); miningField.setOutlierTreatment(OutlierTreatmentMethodType.AS_EXTREME_VALUES); miningField.setLowValue(0.0); miningField.setHighValue(10.0); Object value = 15.0; FieldValue fieldValue = ArgumentUtil.prepare(dataField, miningField, value); assertEquals(10.0, fieldValue.getValue()); }
@Test public void testEvaluateDiscretize() { Discretize discretize = new Discretize("field", DataType.INTEGER, new HashMap<Double, String>(), "missing"); EvaluationContext context = new EvaluationContext(); context.setFieldValue("field", FieldValueUtil.create(DataType.INTEGER, 5)); FieldValue result = ExpressionUtil.evaluateDiscretize(discretize, context); assertEquals(FieldValueUtil.create(DataType.STRING, null, "missing"), result); }
@Test public void testGetDataType() { Object str = "Hello"; Object integer = 10; Object flt = 10.5f; Object dbl = 10.5; Object bool = true; Object date = LocalDate.now(); Object time = LocalTime.now(); Object dateTime = LocalDateTime.now(); Object daysSinceDate = new DaysSinceDate(LocalDate.of(1960, 1, 1), 10); Object secondsSinceMidnight = new SecondsSinceMidnight(LocalTime.now()); Object secondsSinceDate = new SecondsSinceDate(LocalDate.of(1960, 1, 1), 3600); assertEquals(DataType.STRING, TypeUtil.getDataType(str)); assertEquals(DataType.INTEGER, TypeUtil.getDataType(integer)); assertEquals(DataType.FLOAT, TypeUtil.getDataType(flt)); assertEquals(DataType.DOUBLE, TypeUtil.getDataType(dbl)); assertEquals(DataType.BOOLEAN, TypeUtil.getDataType(bool)); assertEquals(DataType.DATE, TypeUtil.getDataType(date)); assertEquals(DataType.TIME, TypeUtil.getDataType(time)); assertEquals(DataType.DATE_TIME, TypeUtil.getDataType(dateTime)); assertEquals(DataType.DATE_DAYS_SINCE_1960, TypeUtil.getDataType(daysSinceDate)); assertEquals(DataType.TIME_SECONDS, TypeUtil.getDataType(secondsSinceMidnight)); assertEquals(DataType.DATE_TIME_SECONDS_SINCE_1960, TypeUtil.getDataType(secondsSinceDate)); assertThrows(EvaluationException.class, () -> TypeUtil.getDataType(null)); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testAcceptable() { Object expected = 10; Object actual = 10.0; double precision = 0.1; double zeroThreshold = 0.0; boolean result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertTrue(result); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateFieldRef() { FieldRef fieldRef = new FieldRef("fieldName"); EvaluationContext context = new EvaluationContext(); context.setFieldValue("fieldName", new FieldValue("fieldValue")); FieldValue result = ExpressionUtil.evaluateFieldRef(fieldRef, context); assertEquals(new FieldValue("fieldValue"), result); }
@Test public void testIsInvalid() { DataField dataField = new DataField("fieldName", DataType.STRING); Object value = "validValue"; assertFalse(ArgumentUtil.isInvalid(dataField, value)); value = null; assertFalse(ArgumentUtil.isInvalid(dataField, value)); dataField = new DataField("fieldName", DataType.INTEGER); value = "invalidValue"; assertTrue(ArgumentUtil.isInvalid(dataField, value)); }
@Test public void testGetConstantDataType() { assertEquals(DataType.INTEGER, TypeUtil.getConstantDataType("123")); assertEquals(DataType.FLOAT, TypeUtil.getConstantDataType("123.45")); assertEquals(DataType.STRING, TypeUtil.getConstantDataType("abc")); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testBinaryAnd() { assertTrue(PredicateUtil.binaryAnd(true, true)); assertFalse(PredicateUtil.binaryAnd(true, false)); assertFalse(PredicateUtil.binaryAnd(false, true)); assertFalse(PredicateUtil.binaryAnd(false, false)); assertNull(PredicateUtil.binaryAnd(null, true)); assertNull(PredicateUtil.binaryAnd(true, null)); assertFalse(PredicateUtil.binaryAnd(null, false)); assertNull(PredicateUtil.binaryAnd(null, null)); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testCreate() { String value = "testValue"; FieldName fieldName = FieldName.create(value); assertNotNull(fieldName); assertEquals(value, fieldName.value); }
@Test public void testContains() { Interval interval = new Interval(2.0, 5.0, Interval.Closure.OPEN_CLOSED); assertTrue(DiscretizationUtil.contains(interval, 3.0)); assertFalse(DiscretizationUtil.contains(interval, 1.0)); assertFalse(DiscretizationUtil.contains(interval, 6.0)); assertTrue(DiscretizationUtil.contains(interval, 5.0)); assertFalse(DiscretizationUtil.contains(interval, 2.0)); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue1 = new FieldValue("field1", "value1"); FieldValue fieldValue2 = new FieldValue("field2", "value2"); values.add(fieldValue1); values.add(fieldValue2); FunctionUtil functionUtil = new FunctionUtil(); FieldValue result = functionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateAggregate() { Aggregate aggregate = new Aggregate(new Field("field"), Aggregate.Function.COUNT, null); EvaluationContext context = new EvaluationContext(); Collection<Integer> values = Arrays.asList(1, 2, 3, null, 4, 5, null); FieldValue fieldValue = FieldValueUtil.create(values); FieldName groupName = new FieldName("groupField"); ExpressionUtil.evaluateAggregate(aggregate, context); assertEquals(5, ExpressionUtil.evaluateAggregate(aggregate, context).getValue()); aggregate = new Aggregate(new Field("field"), Aggregate.Function.SUM, null); assertEquals(15, ExpressionUtil.evaluateAggregate(aggregate, context).getValue()); aggregate = new Aggregate(new Field("field"), Aggregate.Function.AVERAGE, null); assertEquals(3, ExpressionUtil.evaluateAggregate(aggregate, context).getValue()); aggregate = new Aggregate(new Field("field"), Aggregate.Function.MIN, null); assertEquals(1, ExpressionUtil.evaluateAggregate(aggregate, context).getValue()); aggregate = new Aggregate(new Field("field"), Aggregate.Function.MAX, null); assertEquals(5, ExpressionUtil.evaluateAggregate(aggregate, context).getValue()); }
@Test public void testGroupRows() { Map<String, Object> row1 = new HashMap<>(); row1.put("name", "John"); row1.put("age", 25); row1.put("city", "New York"); Map<String, Object> row2 = new HashMap<>(); row2.put("name", "Jane"); row2.put("age", 30); row2.put("city", "Los Angeles"); Map<String, Object> row3 = new HashMap<>(); row3.put("name", "Bob"); row3.put("age", 25); row3.put("city", "New York"); List<Map<String, Object>> table = new ArrayList<>(); table.add(row1); table.add(row2); table.add(row3); List<Map<String, Object>> resultTable = EvaluatorUtil.groupRows("age", table); assertEquals(2, resultTable.size()); Map<String, Object> resultRow1 = resultTable.get(0); assertEquals(25, resultRow1.get("age")); assertEquals(2, resultRow1.size()); Map<String, Object> resultRow2 = resultTable.get(1); assertEquals(30, resultRow2.get("age")); assertEquals(2, resultRow2.size()); }
@Test public void testCreate() { String value = "testValue"; FieldName fieldName = FieldName.create(value); assertNotNull(fieldName); assertEquals(value, fieldName.value); }
@Test public void testIsValid() { DataField dataField = new DataField(DataType.DOUBLE, OpType.CONTINUOUS); dataField.addInterval(new Interval(0.0, 10.0)); Object value = 5.0; boolean result = ArgumentUtil.isValid(dataField, value); assertTrue(result); dataField = new DataField(DataType.STRING, OpType.CATEGORICAL); dataField.addValue(new Value("red", Value.Property.VALID)); dataField.addValue(new Value("blue", Value.Property.VALID)); dataField.addValue(new Value("green", Value.Property.INVALID)); value = "red"; result = ArgumentUtil.isValid(dataField, value); assertTrue(result); value = "green"; result = ArgumentUtil.isValid(dataField, value); assertFalse(result); }
@Test public void testProcess() { Target target = new Target(); target.setMin(10.0); target.setMax(20.0); target.setRescaleFactor(2.0); target.setRescaleConstant(5.0); target.setCastInteger(Target.CastInteger.ROUND); Double value = 15.0; Number expected = 35; Number actual = TargetUtil.process(target, value); assertEquals(expected, actual); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); Tracker tracker = new Tracker(expected); Set<Integer> actual = clc.changedLines(tracker); assertEquals(expected, actual); }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); Tracker tracker = new Tracker(expected); Set<Integer> actual = clc.changedLines(tracker); assertEquals(expected, actual); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.size()); assertTrue(changedLines.containsKey(filePath)); assertEquals(new HashSet<>(Arrays.asList(1)), changedLines.get(filePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("testBranch", tempDir, changedFiles); Set<Integer> expectedLines = new HashSet<>(); expectedLines.add(1); assertEquals(expectedLines, changedLines.get(filePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newFile.txt"); Files.write(newFilePath, "new content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Add new file to test branch").call(); GitScmProvider scmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = scmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); Tracker tracker = new Tracker(expected); Set<Integer> actual = clc.changedLines(tracker); assertEquals(expected, actual); }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBlameCommand() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); BlameCommand blameCommand = gitScmProvider.blameCommand(); assertEquals(jgitBlameCommand, blameCommand); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("C:/Users/username/Documents/project/src/main/java/com/example/MyClass.java"); Path expected = Paths.get("src/main/java/com/example/MyClass.java"); assertEquals(expected, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("testBranch", tempDir, changedFiles); Set<Integer> expectedLines = new HashSet<>(); expectedLines.add(1); assertEquals(expectedLines, changedLines.get(filePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newTestFile.txt"); Files.write(newFilePath, "new test content".getBytes()); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testGitScmProviderKey() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); String expectedKey = "git"; String actualKey = gitScmProvider.key(); assertEquals(expectedKey, actualKey); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newTestFile.txt"); Files.write(newFilePath, "new test content".getBytes()); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.get(filePath).size()); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testSupports() { File baseDir = new File("path/to/base/dir"); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); boolean result = gitScmProvider.supports(baseDir); assertTrue(result); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testNewThread() { ForkJoinPool pool = new ForkJoinPool(); GitThreadFactory factory = new GitThreadFactory(); ForkJoinWorkerThread thread = factory.newThread(pool); assertNotNull(thread); assertEquals("GitThreadFactory-0", thread.getName()); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.get(filePath).size()); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.size()); assertTrue(changedLines.containsKey(filePath)); assertEquals(new HashSet<>(Arrays.asList(1)), changedLines.get(filePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testDefine() { Context context = mock(Context.class); GitPlugin gitPlugin = new GitPlugin(); gitPlugin.define(context); verify(context).addExtensions(JGitBlameCommand.class, GitScmProvider.class, GitIgnoreCommand.class); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("src/test/resources")); when(input.filesToBlame()).thenReturn(Collections.singletonList(new InputFile("test.txt"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blameResult(any(BlameResult.class)); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("C:/Users/username/Documents/project/src/main/java/com/example/MyClass.java"); Path expected = Paths.get("src/main/java/com/example/MyClass.java"); assertEquals(expected, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newTestFile.txt"); Files.write(newFilePath, "new test content".getBytes()); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.get(filePath).size()); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); Tracker tracker = new Tracker(expected); Set<Integer> actual = clc.changedLines(); assertEquals(expected, actual); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("C:/Users/username/Documents/project/src/main/java/com/example/MyClass.java"); Path expected = Paths.get("src/main/java/com/example/MyClass.java"); assertEquals(expected, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testRevisionId() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("path/to/repo"); String revisionId = gitScmProvider.revisionId(path); assertNotNull(revisionId); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newFile.txt"); Files.write(newFilePath, "new content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Add new file to test branch").call(); GitScmProvider scmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = scmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in testBranch").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.get(filePath).size()); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); Tracker tracker = new Tracker(expected); Set<Integer> actual = clc.changedLines(); assertEquals(expected, actual); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("test")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("testFile"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("testRepo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Path newFilePath = tempDir.resolve("newTestFile.txt"); Files.write(newFilePath, "new test content".getBytes()); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("testBranch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }