@Test public void testExecute() { RosetteApiWrapper mockRosAPI = mock(RosetteApiWrapper.class); RosetteAbstractProcessor processor = new RosetteAbstractProcessor(mockRosAPI, "testTag", "testDescription", "testProcessorType", "inputField", "targetField"); Map<String, Object> testDocData = new HashMap<>(); testDocData.put("inputField", "example input text"); IngestDocument testIngestDocument = new IngestDocument(testDocData); IngestDocument resultIngestDocument = processor.execute(testIngestDocument); assertTrue(resultIngestDocument.hasField("inputField")); assertTrue(resultIngestDocument.hasField("targetField")); }
@Test public void testFormatToUserFriendlyFormat() { Date date = new Date(); DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ"); String expected = dateFormat.format(date); String result = DateHelper.formatToUserFriendlyFormat(date); assertEquals(expected, result); }
@Test public void testHasDescription() { UiLesson uiLessonWithDescription = new UiLesson(); uiLessonWithDescription.setDescription("Test description"); assertTrue(uiLessonWithDescription.hasDescription()); UiLesson uiLessonWithoutDescription = new UiLesson(); uiLessonWithoutDescription.setDescription(""); assertFalse(uiLessonWithoutDescription.hasDescription()); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0, 10); FieldValue value = FieldValueUtil.create(5.0); FieldValue expectedNormalizedValue = FieldValueUtil.create(0.5); FieldValue actualNormalizedValue = NormalizationUtil.normalize(normContinuous, value); assertEquals(expectedNormalizedValue, actualNormalizedValue); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(10), new FieldValue(20)); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(30), result); }
@Test public void testGetResultDataType() { DataType expectedResult = DataType.DOUBLE; DataType result = TypeUtil.getResultDataType(DataType.FLOAT, DataType.DOUBLE); assertEquals(expectedResult, result); }
@Test public void testDenormalize() { List<LinearNorm> linearNorms = new ArrayList<>(); linearNorms.add(new LinearNorm(0, 0)); linearNorms.add(new LinearNorm(50, 0.5)); linearNorms.add(new LinearNorm(100, 1.0)); NormContinuous normContinuous = new NormContinuous(linearNorms); double value = 0.75; double expectedResult = 75.0; assertEquals(expectedResult, NormalizationUtil.denormalize(normContinuous, value), 0.001); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "key1", "value1"); table.put(1, "key2", "value2"); table.put(2, "key1", "value1"); table.put(2, "key2", "value3"); Map<String, FieldValue> values = new HashMap<>(); values.put("key1", FieldValue.from("value1")); values.put("key2", FieldValue.from("value3")); Map<String, String> expectedResult = new HashMap<>(); expectedResult.put("key1", "value1"); expectedResult.put("key2", "value3"); assertEquals(expectedResult, InlineTableUtil.match(table, values)); }
@Test public void testIsZero() { Number value = 0.001; double zeroThreshold = 0.01; assertTrue(VerificationUtil.isZero(value, zeroThreshold)); }
@Test public void testEvaluateConstant() { Constant constant = new Constant("42", DataType.INT); EvaluationContext context = new EvaluationContext(); FieldValue result = ExpressionUtil.evaluateConstant(constant, context); assertEquals(new FieldValue(DataType.INT, "42"), result); }
@Test public void testUnmarshal() { String value = "testFieldName"; FieldName fieldName1 = FieldName.unmarshal(value); FieldName fieldName2 = FieldName.unmarshal(value); assertEquals(fieldName1, fieldName2); }
@Test public void testEvaluateSimilarity() { ComparisonMeasure comparisonMeasure = new ComparisonMeasure(new Jaccard()); List<ComparisonField> comparisonFields = new ArrayList<>(); comparisonFields.add(new ComparisonField("A")); comparisonFields.add(new ComparisonField("B")); comparisonFields.add(new ComparisonField("C")); BitSet flags = new BitSet(); flags.set(0); flags.set(2); BitSet referenceFlags = new BitSet(); referenceFlags.set(1); referenceFlags.set(2); Double similarity = MeasureUtil.evaluateSimilarity(comparisonMeasure, comparisonFields, flags, referenceFlags); assertEquals(0.3333, similarity, 0.0001); }
@Test public void testParse() { assertEquals("Hello", TypeUtil.parse(DataType.STRING, "Hello")); }
@Test public void testEvaluate() { EvaluationContext context = new EvaluationContext(); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); Apply apply = new Apply("add", values); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(5), result); }
@Test public void testBinaryXor() { Boolean left = true; Boolean right = false; Boolean expected = true; Boolean result = PredicateUtil.binaryXor(left, right); assertEquals(expected, result); }
@Test public void testDecode() { Computable computable = () -> 42; Object decodedObject = EvaluatorUtil.decode(computable); assertEquals(42, decodedObject); }
@Test public void testEvaluate() { FunctionUtil functionUtil = new FunctionUtil(); Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); EvaluationContext context = mock(EvaluationContext.class); when(context.resolveFunction("sum")).thenReturn(null); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(5, result.getValue()); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(0, "key1", "value1"); table.put(0, "key2", "value2"); table.put(1, "key1", "value3"); table.put(1, "key2", "value4"); Map<String, FieldValue> values = new HashMap<>(); values.put("key1", new FieldValue("value3")); values.put("key2", new FieldValue("value4")); Map<String, String> expectedResult = new HashMap<>(); expectedResult.put("key1", "value3"); expectedResult.put("key2", "value4"); Map<String, String> actualResult = InlineTableUtil.match(table, values); assertEquals(expectedResult, actualResult); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(5), new FieldValue(10)); EvaluationContext context = new EvaluationContext(); context.addFunction("sum", new DefineFunction("sum", (args) -> new FieldValue(args.get(0).asInteger() + args.get(1).asInteger()))); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(15), result); }
@Test public void testEvaluateMapValues() { EvaluationContext context = new EvaluationContext(); MapValues mapValues = new MapValues(DataType.STRING); mapValues.setMapMissingTo("missing"); List<FieldColumnPair> fieldColumnPairs = new ArrayList<>(); fieldColumnPairs.add(new FieldColumnPair(new Field("field1"), "column1")); fieldColumnPairs.add(new FieldColumnPair(new Field("field2"), "column2")); mapValues.setFieldColumnPairs(fieldColumnPairs); context.setValue("field1", FieldValueUtil.create(DataType.STRING, "value1", null)); context.setValue("field2", FieldValueUtil.create(DataType.STRING, "value2", null)); FieldValue result = ExpressionUtil.evaluateMapValues(mapValues, context); assertNotNull(result); assertEquals(DataType.STRING, result.getDataType()); assertTrue(result.getValue() instanceof Map); Map<String, FieldValue> resultMap = (Map<String, FieldValue>) result.getValue(); assertEquals(2, resultMap.size()); assertEquals("value1", resultMap.get("column1").getValue()); assertEquals("value2", resultMap.get("column2").getValue()); }
@Test public void testEvaluateNormContinuous() { NormContinuous normContinuous = new NormContinuous(); normContinuous.setField("age"); normContinuous.setMapMissingTo(0.5); normContinuous.setOutliers(OutlierTreatmentMethodType.AS_IS); ContinuousDistribution distribution = new GaussianDistribution(); distribution.setMean(30.0); distribution.setStandardDeviation(5.0); normContinuous.setDistribution(distribution); EvaluationContext context = new DefaultEvaluationContext(null); context.declare("age", FieldValueUtil.create(25.0)); FieldValue result = ExpressionUtil.evaluateNormContinuous(normContinuous, context); assertNotNull(result); assertEquals(FieldValueUtil.create(0.0797884580962), result, 0.000001); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0.0, 100.0); FieldValue value = FieldValueUtil.create(50.0); FieldValue expected = FieldValueUtil.create(0.5); assertEquals(expected, NormalizationUtil.normalize(normContinuous, value)); }
@Test public void testCast() { DataType dataType = DataType.STRING; Object value = 123; Object result = TypeUtil.cast(dataType, value); assertEquals("123", result); }
@Test public void testEvaluate() { FunctionUtil util = new FunctionUtil(); Apply apply = new Apply("add"); List<FieldValue> values = Arrays.asList(new FieldValue(5), new FieldValue(3)); EvaluationContext context = new EvaluationContext(); FieldValue result = util.evaluate(apply, values, context); assertEquals(new FieldValue(8), result); }
@Test public void testBinaryOr() { Boolean left = true; Boolean right = false; Boolean expectedResult = true; Boolean result = PredicateUtil.binaryOr(left, right); assertEquals(expectedResult, result); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue("1"), new FieldValue("2"), new FieldValue("3")); EvaluationContext context = new EvaluationContext(); context.defineFunction("sum", new SumFunction()); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue("6"), result); }
@Test public void testEvaluateNormDiscrete() { NormDiscrete normDiscrete = new NormDiscrete(); normDiscrete.setField("field"); normDiscrete.setValue("testValue"); normDiscrete.setMapMissingTo("-1"); EvaluationContext context = new EvaluationContext(); context.declare("field", FieldValueUtil.create("testValue")); FieldValue result = ExpressionUtil.evaluateNormDiscrete(normDiscrete, context); assertEquals(FieldValueUtil.create(1d), result); }
@Test public void testEvaluate() { Apply apply = new Apply("SUM"); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); EvaluationContext context = new SimpleEvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(5, result.getIntValue()); }
@Test public void testGetValue() { IntSparseArray intSparseArray = new IntSparseArray(); intSparseArray.put(1, 10); Integer result = SparseArrayUtil.getValue(intSparseArray, 1); assertEquals(Integer.valueOf(10), result); }
@Test public void testMarshal() { FieldName fieldName = new FieldName("testValue"); String result = FieldName.marshal(fieldName); assertEquals("testValue", result); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(1), new FieldValue(2)); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(3), result); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(5, result.getIntValue()); }
@Test public void testPrepare() { DataField dataField = new DataField("testField", OpType.CONTINUOUS, DataType.DOUBLE); MiningField miningField = new MiningField("testField", UsageType.ACTIVE); miningField.setOutlierTreatment(OutlierTreatmentMethodType.AS_EXTREME_VALUES); miningField.setLowValue(0.0); miningField.setHighValue(100.0); miningField.setMissingValueReplacement(50.0); miningField.setInvalidValueTreatment(InvalidValueTreatmentMethodType.AS_MISSING); Object value = 150.0; FieldValue result = ArgumentUtil.prepare(dataField, miningField, value); assertEquals(100.0, result.getValue()); }
@Test public void testEvaluateDiscretize() { Discretize discretize = new Discretize(); discretize.setField("age"); discretize.setDataType(DataType.INTEGER); discretize.setMapMissingTo(-1); Map<String, Object> values = new HashMap<>(); values.put("age", 25); EvaluationContext context = new EvaluationContext(values); FieldValue result = ExpressionUtil.evaluateDiscretize(discretize, context); Assert.assertEquals(Integer.valueOf(25), result.getValue()); }
@Test public void testGetDataType() { String stringValue = "test"; int intValue = 42; float floatValue = 3.14f; double doubleValue = 3.1415; boolean booleanValue = true; LocalDate localDateValue = LocalDate.of(2021, 6, 15); LocalDateTime localDateTimeValue = LocalDateTime.of(2021, 6, 15, 14, 30); assertEquals(DataType.STRING, TypeUtil.getDataType(stringValue)); assertEquals(DataType.INTEGER, TypeUtil.getDataType(intValue)); assertEquals(DataType.FLOAT, TypeUtil.getDataType(floatValue)); assertEquals(DataType.DOUBLE, TypeUtil.getDataType(doubleValue)); assertEquals(DataType.BOOLEAN, TypeUtil.getDataType(booleanValue)); assertEquals(DataType.DATE, TypeUtil.getDataType(localDateValue)); assertEquals(DataType.DATE_TIME, TypeUtil.getDataType(localDateTimeValue)); }
@Test public void testEvaluate() { FunctionUtil functionUtil = new FunctionUtil(); Apply apply = new Apply("add"); List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue(3)); values.add(new FieldValue(4)); EvaluationContext context = new EvaluationContext() { @Override public DefineFunction resolveFunction(String functionName) { return null; } }; FieldValue result = functionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(7), result); }
@Test public void testAcceptable() { double expectedValue = 3.14; double actualValue = 3.140001; double precision = 0.0001; double zeroThreshold = 0.0000001; boolean result = VerificationUtil.acceptable(expectedValue, actualValue, precision, zeroThreshold); assertTrue(result); }
@Test public void testEvaluate() { Apply apply = new Apply("sum"); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(5), result); }
@Test public void testEvaluateFieldRef() { FieldRef fieldRef = new FieldRef("fieldName", "defaultValue"); EvaluationContext context = new EvaluationContext(Collections.singletonMap("fieldName", "fieldValue")); FieldValue result = ExpressionUtil.evaluateFieldRef(fieldRef, context); assertEquals(new FieldValue("fieldValue"), result); }
@Test public void testIsInvalid() { DataField dataField = new DataField("field", String.class, "default"); String value = "validValue"; assertFalse(ArgumentUtil.isInvalid(dataField, value)); }
@Test public void testGetConstantDataType() { assertEquals(DataType.FLOAT, TypeUtil.getConstantDataType("3.14")); assertEquals(DataType.INTEGER, TypeUtil.getConstantDataType("42")); assertEquals(DataType.STRING, TypeUtil.getConstantDataType("hello")); }
@Test public void testEvaluate() { Apply apply = new Apply("add"); List<FieldValue> values = Arrays.asList(new FieldValue(3), new FieldValue(4)); EvaluationContext context = new EvaluationContext(); context.addFunction("add", (args) -> new FieldValue(args.get(0).getInt() + args.get(1).getInt())); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(7, result.getInt()); }
@Test public void testBinaryAnd() { assertNull(PredicateUtil.binaryAnd(null, null)); assertFalse(PredicateUtil.binaryAnd(true, false)); assertNull(PredicateUtil.binaryAnd(null, true)); assertNull(PredicateUtil.binaryAnd(false, null)); assertTrue(PredicateUtil.binaryAnd(true, true)); }
@Test public void testEvaluate() { Apply apply = new Apply("exampleFunction"); List<FieldValue> fieldValues = new ArrayList<>(); fieldValues.add(new FieldValue(10)); fieldValues.add(new FieldValue(20)); EvaluationContext context = new EvaluationContext(); Function function = new Function() { @Override public FieldValue evaluate(List<FieldValue> values) { return new FieldValue(values.get(0).getIntValue() + values.get(1).getIntValue()); } }; FunctionUtil.registerFunction("exampleFunction", function); FieldValue result = FunctionUtil.evaluate(apply, fieldValues, context); assertEquals(30, result.getIntValue()); }
@Test public void testCreate() { String value = "testValue"; FieldName expected = new FieldName(value); FieldName actual = FieldName.create(value); assertEquals(expected, actual); }
@Test public void testContains() { Interval interval = new Interval(1.0, 3.0, Interval.Closure.OPEN_CLOSED); boolean result = DiscretizationUtil.contains(interval, 2.0); assertTrue(result); }
@Test public void testEvaluate() { Apply apply = new Apply("add"); List<FieldValue> values = Arrays.asList(new FieldValue(2), new FieldValue(3)); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue(5), result); }
@Test public void testEvaluateAggregate() { ExpressionUtil expressionUtil = new ExpressionUtil(); EvaluationContext context = new EvaluationContext(Collections.emptyMap()); Aggregate aggregate = new Aggregate(Aggregate.Function.COUNT, new FieldName("key"), null); LinkedHashMap<String, Object> data = new LinkedHashMap<>(); data.put("key", Arrays.asList(1, 2, 3, 4)); context.pushFrame(data); FieldValue result = ExpressionUtil.evaluateAggregate(aggregate, context); assertEquals(FieldValueUtil.create(4), result); }
@Test public void testGroupRows() { List<Map<String, Object>> table = new ArrayList<>(); Map<String, Object> row1 = new HashMap<>(); row1.put("name", "Alice"); row1.put("age", 30); row1.put("city", "New York"); table.add(row1); Map<String, Object> row2 = new HashMap<>(); row2.put("name", "Bob"); row2.put("age", 25); row2.put("city", "New York"); table.add(row2); Map<String, Object> row3 = new HashMap<>(); row3.put("name", "Charlie"); row3.put("age", 22); row3.put("city", "Los Angeles"); table.add(row3); List<Map<String, Object>> resultTable = EvaluatorUtil.groupRows("city", table); List<Map<String, Object>> expectedTable = new ArrayList<>(); Map<String, Object> newRow1 = new HashMap<>(); newRow1.put("name", Arrays.asList("Alice", "Bob")); newRow1.put("age", Arrays.asList(30, 25)); newRow1.put("city", "New York"); Map<String, Object> newRow2 = new HashMap<>(); newRow2.put("name", Collections.singletonList("Charlie")); newRow2.put("age", Collections.singletonList(22)); newRow2.put("city", "Los Angeles"); expectedTable.add(newRow1); expectedTable.add(newRow2); assertEquals(expectedTable, resultTable); }
@Test public void testCreate() { String testValue = "test_field"; FieldName result = FieldName.create(testValue); assertNotNull(result); assertEquals(testValue, result.getValue()); }
@Test public void testIsValid() { DataField dataField = new DataField("fieldName", DataType.DOUBLE, OpType.CONTINUOUS); Interval interval = new Interval(Interval.Closure.CLOSED_CLOSED, 0.0, 10.0); dataField.addInterval(interval); Object value = 5.0; boolean result = ArgumentUtil.isValid(dataField, value); assertTrue(result); }
@Test public void testProcess() { Target target = new Target(0.0, 10.0, 2.0, 1.0, Target.CastInteger.ROUND); Double value = 4.5; Number expectedResult = 10; assertEquals(expectedResult, TargetUtil.process(target, value)); }
@Test public void testChangedLines() { Set<Integer> expectedChangedLines = new HashSet<>(Arrays.asList(1, 2, 3)); Tracker mockTracker = Mockito.mock(Tracker.class); Mockito.when(mockTracker.changedLines()).thenReturn(expectedChangedLines); ChangedLinesComputer changedLinesComputer = new ChangedLinesComputer(mockTracker); Set<Integer> actualChangedLines = changedLinesComputer.changedLines(); assertEquals(expectedChangedLines, actualChangedLines); }
@Test public void testForkDate() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String referenceBranchName = "testBranch"; Path projectBaseDir = Paths.get("src/test/resources/gitRepo"); Instant result = gitScmProvider.forkDate(referenceBranchName, projectBaseDir); assertNotNull(result); }
@Test public void testChangedLines() { Set<Integer> expectedChangedLines = new HashSet<>(Arrays.asList(1, 2, 3)); LineTracker mockTracker = mock(LineTracker.class); when(mockTracker.changedLines()).thenReturn(expectedChangedLines); ChangedLinesComputer changedLinesComputer = new ChangedLinesComputer(mockTracker); Set<Integer> actualChangedLines = changedLinesComputer.changedLines(); assertEquals(expectedChangedLines, actualChangedLines); }
@Test public void testBranchChangedLines() { AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path projectBaseDir = Paths.get("src/test/resources/project"); Set<Path> changedFiles = new HashSet<>(Arrays.asList(Paths.get("src/test/resources/project/changedFile1.java"), Paths.get("src/test/resources/project/changedFile2.java"))); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertEquals(2, result.size()); }
@Test public void testBlame() { PathResolver pathResolver = new PathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand command = new JGitBlameCommand(pathResolver, analysisWarnings); BlameInput mockInput = mock(BlameInput.class); when(mockInput.fileSystem()).thenReturn(new TestFileSystem()); when(mockInput.filesToBlame()).thenReturn(Collections.singletonList(new TestInputFileBuilder("path/to/file").build())); BlameOutput mockOutput = mock(BlameOutput.class); command.blame(mockInput, mockOutput); verify(mockOutput, atLeastOnce()).consume(any(InputFile.class), any(LineInfo.class)); }
@Test public void testBranchChangedFiles() { System2 system2 = mock(System2.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path rootBaseDir = Paths.get("src/test/resources/git-repo"); String targetBranchName = "master"; Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertEquals(2, changedFiles.size()); assertTrue(changedFiles.contains(rootBaseDir.resolve("file1.txt"))); assertTrue(changedFiles.contains(rootBaseDir.resolve("file2.txt"))); }
@Test public void testBlame() { PathResolver pathResolver = new PathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); FileSystem fileSystem = mock(FileSystem.class); when(fileSystem.baseDir()).thenReturn(Paths.get(".")); BlameInput input = mock(BlameInput.class); when(input.fileSystem()).thenReturn(fileSystem); when(input.filesToBlame()).thenReturn(Collections.emptyList()); BlameOutput output = mock(BlameOutput.class); jGitBlameCommand.blame(input, output); verify(output, times(0)).blameResult(any(), any()); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "myTargetBranch"; Path projectBaseDir = Paths.get("myProjectBaseDir"); Set<Path> changedFiles = new HashSet<>(Arrays.asList(Paths.get("file1.txt"), Paths.get("file2.txt"))); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(changedLines); assertEquals(2, changedLines.size()); }
@Test public void testBranchChangedFiles() { Path tempDir = Files.createTempDirectory("testBranchChangedFiles"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Files.write(tempDir.resolve("test.txt"), "Hello".getBytes()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("test-branch").call(); git.checkout().setName("test-branch").call(); Files.write(tempDir.resolve("test.txt"), "Hello, world!".getBytes()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Update test.txt").call(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); GitScmProvider gitScmProvider = new GitScmProvider(null, analysisWarnings, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("master", tempDir); Set<Path> expectedChangedFiles = new HashSet<>(); expectedChangedFiles.add(tempDir.resolve("test.txt")); assertEquals(expectedChangedFiles, changedFiles); } catch (IOException | GitAPIException e) { fail("Unexpected exception during test setup: " + e.getMessage()); } }
@Test public void testChangedLines() { ChangedLinesTracker tracker = mock(ChangedLinesTracker.class); Set<Integer> expectedLines = new HashSet<>(Arrays.asList(1, 2, 3)); when(tracker.changedLines()).thenReturn(expectedLines); ChangedLinesComputer computer = new ChangedLinesComputer(tracker); Set<Integer> actualLines = computer.changedLines(); assertEquals(expectedLines, actualLines); }
@Test public void testForkDate() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path projectBaseDir = Paths.get(System.getProperty("user.home")); String referenceBranchName = "dummy_branch"; Instant forkDate = gitScmProvider.forkDate(referenceBranchName, projectBaseDir); assertNotNull(forkDate); }
@Test public void testForkDate() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path projectBaseDir = Paths.get(System.getProperty("user.dir")); String referenceBranchName = "master"; Instant forkDate = gitScmProvider.forkDate(referenceBranchName, projectBaseDir); assertNotNull(forkDate); }
@Test public void testBranchChangedFiles() { System2 system2 = mock(System2.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "test_branch"; Path rootBaseDir = Paths.get("src/test/resources/repo"); Set<Path> expectedResult = new HashSet<>(); expectedResult.add(Paths.get("src/test/resources/repo/new_file.txt")); Set<Path> result = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertEquals(expectedResult, result); }
@Test public void testBranchChangedFiles() { JGitBlameCommand jgitBlameCommand = Mockito.mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = Mockito.mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = Mockito.mock(GitIgnoreCommand.class); System2 system2 = Mockito.mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path rootBaseDir = Paths.get("."); String targetBranchName = "master"; Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertTrue(changedFiles.isEmpty()); }
@Test public void testJGitBlameCommand() { PathResolver pathResolver = new PathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); File fileSystemBaseDir = new File("src/test/resources/git-repository"); FileSystem mockFileSystem = mock(FileSystem.class); Mockito.when(mockFileSystem.baseDir()).thenReturn(fileSystemBaseDir); Collection<InputFile> filesToBlame = new ArrayList<>(); filesToBlame.add(new TestInputFileBuilder("test-", "testFile.java").setModuleBaseDir(fileSystemBaseDir.toPath()).build()); BlameInput mockBlameInput = mock(BlameInput.class); Mockito.when(mockBlameInput.fileSystem()).thenReturn(mockFileSystem); Mockito.when(mockBlameInput.filesToBlame()).thenReturn(filesToBlame); BlameOutput mockBlameOutput = mock(BlameOutput.class); jGitBlameCommand.blame(mockBlameInput, mockBlameOutput); Mockito.verify(mockBlameOutput, Mockito.atLeastOnce()).result(Mockito.any(), Mockito.any()); }
@Test public void testBlameCommand() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); BlameCommand blameCommand = gitScmProvider.blameCommand(); assertEquals(jgitBlameCommand, blameCommand); }
@Test public void testRelativePathFromScmRoot() { JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path scmRoot = Paths.get("src"); Path filePath = scmRoot.resolve("main/java/com/myapp/MyClass.java"); Path relativePath = gitScmProvider.relativePathFromScmRoot(filePath); assertEquals(Paths.get("main/java/com/myapp/MyClass.java"), relativePath); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path projectBaseDir = Paths.get("test/project/dir"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("test/project/dir/changedFile1")); changedFiles.add(Paths.get("test/project/dir/changedFile2")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertEquals(2, result.size()); assertTrue(result.containsKey(Paths.get("test/project/dir/changedFile1"))); assertTrue(result.containsKey(Paths.get("test/project/dir/changedFile2"))); }
@Test public void testJGitBlameCommand() { PathResolver mockPathResolver = mock(PathResolver.class); AnalysisWarnings mockAnalysisWarnings = mock(AnalysisWarnings.class); BlameInput mockBlameInput = mock(BlameInput.class); BlameOutput mockBlameOutput = mock(BlameOutput.class); FileSystem mockFileSystem = mock(FileSystem.class); when(mockBlameInput.fileSystem()).thenReturn(mockFileSystem); when(mockFileSystem.baseDir()).thenReturn(new File(".")); when(mockBlameInput.filesToBlame()).thenReturn(Collections.emptyList()); JGitBlameCommand blameCommand = new JGitBlameCommand(mockPathResolver, mockAnalysisWarnings); blameCommand.blame(mockBlameInput, mockBlameOutput); verify(mockBlameOutput, never()).result(any(), any()); }
@Test public void testBlame() throws Exception { PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand command = new JGitBlameCommand(pathResolver, analysisWarnings); BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(mock(File.class)); Iterable<InputFile> files = Collections.singletonList(mock(InputFile.class)); when(input.filesToBlame()).thenReturn(files); command.blame(input, output); verify(output, atLeastOnce()).result(any(), any(), any()); }
@Test public void testBranchChangedFiles() { AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); GitIgnoreCommand gitIgnoreCommand = new GitIgnoreCommand(); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path rootBaseDir = Paths.get("src/test/resources/test-repo"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertFalse(changedFiles.isEmpty()); }
@Test public void testKey() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); assertEquals("git", gitScmProvider.key()); }
@Test public void testBranchChangedFiles() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); File rootBaseDir = new File("temp"); rootBaseDir.mkdir(); String targetBranchName = "test-branch"; Set<Path> result = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir.toPath()); assertNull(result); rootBaseDir.delete(); }
@Test public void testBranchChangedFiles() { Path tempDir = Files.createTempDirectory("testRepo"); Git.init().setDirectory(tempDir.toFile()).call(); Git git = Git.open(tempDir.toFile()); Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "Test content".getBytes()); git.add().addFilepattern("testFile.txt").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Files.write(filePath, "New content in test branch".getBytes(), StandardOpenOption.APPEND); git.add().addFilepattern("testFile.txt").call(); git.commit().setMessage("Modify file in test branch").call(); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(analysisWarnings); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jGitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("master", tempDir); assertNotNull(changedFiles); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(filePath)); }
@Test public void testBranchChangedFiles() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path rootBaseDir = Paths.get("src/test/resources"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); Set<Path> expectedFiles = new HashSet<>(Arrays.asList( Paths.get("src/test/resources/file1.txt"), Paths.get("src/test/resources/file2.txt"))); assertEquals(expectedFiles, changedFiles); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path projectBaseDir = Paths.get("testProject"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("src/main/java/TestFile1.java")); changedFiles.add(Paths.get("src/main/java/TestFile2.java")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertEquals(2, result.size()); assertTrue(result.containsKey(Paths.get("src/main/java/TestFile1.java"))); assertTrue(result.containsKey(Paths.get("src/main/java/TestFile2.java"))); }
@Test public void testSupports() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); File gitDirectory = new File("temp"); assertTrue(gitScmProvider.supports(gitDirectory)); }
@Test public void testBranchChangedFiles() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path rootBaseDir = Paths.get("."); String targetBranchName = "test-branch"; Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); }
@Test public void testNewThread() { GitThreadFactory gitThreadFactory = new GitThreadFactory(); ForkJoinPool testPool = new ForkJoinPool(1, gitThreadFactory, null, false); ForkJoinWorkerThread testThread = gitThreadFactory.newThread(testPool); assertNotNull(testThread); assertTrue(testThread.getName().startsWith("GitThreadFactory-")); }
@Test public void testBranchChangedLines() { AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "test-branch"; Path projectBaseDir = Paths.get("src/test/resources"); Set<Path> changedFiles = new HashSet<>(Arrays.asList(Paths.get("src/test/resources/file1.txt"), Paths.get("src/test/resources/file2.txt"))); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(changedLines); assertEquals(2, changedLines.size()); assertTrue(changedLines.containsKey(Paths.get("src/test/resources/file1.txt"))); assertTrue(changedLines.containsKey(Paths.get("src/test/resources/file2.txt"))); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path projectBaseDir = Paths.get("src/test/resources/projectBaseDir"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("src/test/resources/projectBaseDir/changedFile1.txt")); changedFiles.add(Paths.get("src/test/resources/projectBaseDir/changedFile2.txt")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertEquals(2, result.size()); assertTrue(result.containsKey(Paths.get("src/test/resources/projectBaseDir/changedFile1.txt"))); assertTrue(result.containsKey(Paths.get("src/test/resources/projectBaseDir/changedFile2.txt"))); }
@Test public void testDefine() { GitPlugin gitPlugin = new GitPlugin(); Context context = new DefaultContext(new Plugin.Context.Builder().build()); gitPlugin.define(context); assertThat(context.all().size(), is(3)); assertThat(context.all(), hasItem(JGitBlameCommand.class)); assertThat(context.all(), hasItem(GitScmProvider.class)); assertThat(context.all(), hasItem(GitIgnoreCommand.class)); }
@Test public void testBranchChangedFiles() { System2 system2 = mock(System2.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path rootBaseDir = Paths.get("src/test/resources/testRepo"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertEquals(2, changedFiles.size()); assertTrue(changedFiles.contains(Paths.get("src/test/resources/testRepo/newFile.txt"))); assertTrue(changedFiles.contains(Paths.get("src/test/resources/testRepo/modifiedFile.txt"))); }
@Test public void testBlame() { PathResolver pathResolver = new PathResolver(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); FileSystemMock fileSystemMock = new FileSystemMock(); InputFile inputFile1 = new InputFile("testFile1.java"); InputFile inputFile2 = new InputFile("testFile2.java"); BlameInput blameInput = new BlameInput(fileSystemMock, Arrays.asList(inputFile1, inputFile2)); BlameOutput blameOutput = new BlameOutput(); jGitBlameCommand.blame(blameInput, blameOutput); assertEquals(2, blameOutput.getBlamedFiles().size()); assertTrue(blameOutput.getBlamedFiles().contains(inputFile1)); assertTrue(blameOutput.getBlamedFiles().contains(inputFile2)); }
@Test public void testRelativePathFromScmRoot() { JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); GitIgnoreCommand gitIgnoreCommand = new GitIgnoreCommand(); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path scmRoot = Paths.get("root"); Path subPath = scmRoot.resolve("subdir/file.txt"); RepositoryBuilder repositoryBuilder = new RepositoryBuilder(scmRoot); repositoryBuilder.setGitDir(scmRoot.resolve(".git")); when(getVerifiedRepositoryBuilder(subPath)).thenReturn(repositoryBuilder); Path result = gitScmProvider.relativePathFromScmRoot(subPath); assertEquals(Paths.get("subdir/file.txt"), result); }
@Test public void testBranchChangedFiles() { Path rootBaseDir = Paths.get("test_repo"); String targetBranchName = "test_branch"; JGitBlameCommand mockJGitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings mockAnalysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand mockGitIgnoreCommand = mock(GitIgnoreCommand.class); System2 mockSystem2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(mockJGitBlameCommand, mockAnalysisWarnings, mockGitIgnoreCommand, mockSystem2); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertFalse(changedFiles.isEmpty()); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path projectBaseDir = Paths.get("src/test/resources/project/"); Path file1 = projectBaseDir.resolve("file1"); Path file2 = projectBaseDir.resolve("file2"); Set<Path> changedFiles = new HashSet<>(Arrays.asList(file1, file2)); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNotNull(result); assertEquals(2, result.size()); }
@Test public void testForkDate() { JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); GitIgnoreCommand gitIgnoreCommand = new GitIgnoreCommand(); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path projectBaseDir = Files.createTempDirectory("testRepo"); try (Repository repo = new FileRepositoryBuilder() .setWorkTree(projectBaseDir.toFile()) .build()) { repo.create(); Git git = new Git(repo); Files.write(projectBaseDir.resolve("test.txt"), "content".getBytes()); git.add().addFilepattern("test.txt").call(); RevCommit commit = git.commit().setMessage("Initial commit").call(); git.checkout().setName("referenceBranch").setCreateBranch(true).call(); Files.write(projectBaseDir.resolve("test2.txt"), "content2".getBytes()); git.add().addFilepattern("test2.txt").call(); git.commit().setMessage("Reference branch commit").call(); git.checkout().setName("master").call(); Instant forkDate = gitScmProvider.forkDate("referenceBranch", projectBaseDir); assertEquals(Instant.ofEpochSecond(commit.getCommitTime()), forkDate); } catch (IOException | GitAPIException e) { fail("Test setup failed: " + e.getMessage()); } }
@Test public void testChangedLines() { ChangedLinesTracker tracker = mock(ChangedLinesTracker.class); Set<Integer> expectedChangedLines = new HashSet<>(Arrays.asList(1, 2, 3)); when(tracker.changedLines()).thenReturn(expectedChangedLines); ChangedLinesComputer computer = new ChangedLinesComputer(tracker); Set<Integer> actualChangedLines = computer.changedLines(); assertEquals(expectedChangedLines, actualChangedLines); }
@Test public void testRelativePathFromScmRoot() { System2 system2 = mock(System2.class); JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path rootPath = Paths.get("/test/root"); Path filePath = Paths.get("/test/root/subdir/file.txt"); Path relativePath = Paths.get("subdir/file.txt"); RepositoryBuilder repositoryBuilder = mock(RepositoryBuilder.class); when(repositoryBuilder.getGitDir()).thenReturn(filePath.toFile()); PowerMockito.mockStatic(Paths.class); PowerMockito.when(Paths.get(rootPath.toUri())).thenReturn(rootPath); PowerMockito.when(Paths.get(filePath.toUri())).thenReturn(filePath); gitScmProvider.relativePathFromScmRoot(filePath); assertEquals(relativePath, gitScmProvider.relativePathFromScmRoot(filePath)); }
@Test public void testRevisionId() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); Path path = Paths.get("test.file"); String expectedRevisionId = "abcd1234"; try (MockedStatic<RepositoryBuilder> mockedRepositoryBuilder = mockStatic(RepositoryBuilder.class); MockedStatic<Ref> mockedRef = mockStatic(Ref.class)) { RepositoryBuilder repositoryBuilder = mock(RepositoryBuilder.class); Repository repository = mock(Repository.class); Ref head = mock(Ref.class); RevWalk revWalk = mock(RevWalk.class); when(repository.resolve(Constants.HEAD)).thenReturn(head); mockedRepositoryBuilder.when(() -> RepositoryBuilder.getVerifiedRepositoryBuilder(path)).thenReturn(repositoryBuilder); when(repositoryBuilder.build()).thenReturn(repository); mockedRef.when(() -> Ref.getHead(revWalk)).thenReturn(head); when(head.getObjectId()).thenReturn(ObjectId.fromString(expectedRevisionId)); String actualRevisionId = gitScmProvider.revisionId(path); assertEquals(expectedRevisionId, actualRevisionId); } catch (IOException e) { fail("Unexpected IOException occurred: " + e.getMessage()); } }
@Test public void testBranchChangedFiles() { JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); GitIgnoreCommand gitIgnoreCommand = new GitIgnoreCommand(); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Path rootBaseDir = Paths.get("src/test/resources/repo"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertFalse(changedFiles.isEmpty()); }
@Test public void testBlame() throws IOException { Path workingDir = Files.createTempDirectory("test_repo"); PathRepoBuilder repoBuilder = new PathRepoBuilder(workspace, workingDir); PathResolver pathResolver = new PathResolver(workingDir); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); repoBuilder.create("test.txt", "Initial content"); repoBuilder.commit("Initial commit"); DefaultFileSystem fileSystem = new DefaultFileSystem(workingDir); fileSystem.add(new TestInputFileBuilder("", "test.txt").setContents("Initial content").build()); BlameInput input = new DefaultBlameInput(fileSystem, Collections.singleton("test.txt")); List<Blame> blameResults = new ArrayList<>(); BlameOutput output = blame -> blameResults.add(blame); jgitBlameCommand.blame(input, output); assertEquals(1, blameResults.size()); Blame result = blameResults.get(0); assertEquals("test.txt", result.inputFile().relativePath()); assertEquals(1, result.lines()); assertEquals("Initial commit", result.commit("0").summary()); }
@Test public void testBranchChangedLines() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String targetBranchName = "testBranch"; Set<Path> changedFiles = new HashSet<>( Arrays.asList( Paths.get("src/main/java/com/example/MyClass.java"), Paths.get("src/main/java/com/example/AnotherClass.java") ) ); try { Path projectBaseDir = Files.createTempDirectory("testRepo"); Files.createDirectories(projectBaseDir.resolve(".git")); Map<Path, Set<Integer>> result = gitScmProvider.branchChangedLines(targetBranchName, projectBaseDir, changedFiles); assertNull(result); verify(analysisWarnings, times(1)).addUnique(anyString()); } catch (IOException e) { fail("Unexpected exception: " + e.getMessage()); } }
@Test public void testForkDate() { JGitBlameCommand jgitBlameCommand = mock(JGitBlameCommand.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); GitIgnoreCommand gitIgnoreCommand = mock(GitIgnoreCommand.class); System2 system2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); String referenceBranchName = "testBranch"; Path projectBaseDir = Paths.get("testProject"); Instant forkDate = gitScmProvider.forkDate(referenceBranchName, projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer computer = new ChangedLinesComputer(); Set<Integer> expectedResult = new HashSet<>(Arrays.asList(1, 2, 3)); tracker.setChangedLines(expectedResult); Set<Integer> actualResult = computer.changedLines(); assertEquals(expectedResult, actualResult); }
@Test public void testBlame() { Path baseDir = Files.createTempDirectory("testJGitBlameCommand"); FileSystem fileSystem = new InMemoryFileSystem(baseDir); List<InputFile> filesToBlame = Collections.singletonList(new TestInputFile("file.txt", "content")); BlameInput input = new BlameInput() { @Override public FileSystem fileSystem() { return fileSystem; } @Override public Iterable<InputFile> filesToBlame() { return filesToBlame; } }; BlameOutput output = new BlameOutput() { @Override public void blamed(BitSet lines, InputFile inputFile, BlameLine[] arr) { assertThat(lines.cardinality()).isEqualTo(0); assertThat(arr.length).isEqualTo(1); assertThat(inputFile.relativePath()).isEqualTo("file.txt"); assertThat(arr[0].revision()).isNull(); } }; AnalysisWarnings analysisWarnings = new AnalysisWarnings(); PathResolver pathResolver = new PathResolver(); JGitBlameCommand command = new JGitBlameCommand(pathResolver, analysisWarnings); command.blame(input, output); }
@Test public void testBranchChangedFiles() { AnalysisWarnings mockAnalysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand mockJGitBlameCommand = mock(JGitBlameCommand.class); GitIgnoreCommand mockGitIgnoreCommand = mock(GitIgnoreCommand.class); System2 mockSystem2 = mock(System2.class); GitScmProvider gitScmProvider = new GitScmProvider(mockJGitBlameCommand, mockAnalysisWarnings, mockGitIgnoreCommand, mockSystem2); String targetBranchName = "testBranch"; Path rootBaseDir = Paths.get("src/test/resources/testGitRepo"); Set<Path> changedFiles = gitScmProvider.branchChangedFiles(targetBranchName, rootBaseDir); assertNotNull(changedFiles); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(rootBaseDir.resolve("testFile.txt"))); }