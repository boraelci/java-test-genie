@Test public void testExecute() throws Exception { RosetteApiWrapper rosAPI = new RosetteApiWrapper("apiKey"); String tag = "testTag"; String description = "testDescription"; String processorType = "testProcessorType"; String inputField = "testInputField"; String targetField = "testTargetField"; RosetteAbstractProcessor processor = new RosetteAbstractProcessor(rosAPI, tag, description, processorType, inputField, targetField); IngestDocument ingestDocument = new IngestDocument("testId", "testIndex"); ingestDocument.setFieldValue(inputField, "This is a test document."); processor.execute(ingestDocument); assertFalse(ingestDocument.hasField(targetField)); assertEquals(ingestDocument.getFieldValue(inputField, String.class), "This is a test document."); }
@Test public void testFormatToUserFriendlyFormat() { Date date = new Date(); String expected = DateFormat.getDateInstance(DateFormat.FULL).format(date); String result = DateHelper.formatToUserFriendlyFormat(date); assertEquals(expected, result); }
@Test public void testHasDescription() { UiLesson uiLesson = new UiLesson(); assertFalse(uiLesson.hasDescription()); uiLesson.description = ""; assertFalse(uiLesson.hasDescription()); uiLesson.description = "Lesson description"; assertTrue(uiLesson.hasDescription()); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0.0, 10.0); FieldValue value = FieldValueUtil.create(5.0); FieldValue result = NormalizationUtil.normalize(normContinuous, value); assertEquals(0.5, result.asNumber().doubleValue(), 0.001); }
@Test public void evaluateTest() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue = new FieldValue("fieldValue"); values.add(fieldValue); FunctionUtil.evaluate(apply, values, context); }
@Test public void testGetResultDataType() { DataType left = DataType.STRING; DataType right = DataType.INTEGER; DataType result = TypeUtil.getResultDataType(left, right); assertEquals(DataType.OBJECT, result); }
@Test public void testDenormalize() { NormContinuous normContinuous = new NormContinuous(); List<LinearNorm> linearNorms = new ArrayList<>(); linearNorms.add(new LinearNorm(0.0, 0.0)); linearNorms.add(new LinearNorm(1.0, 1.0)); normContinuous.setLinearNorms(linearNorms); double value = 0.5; double result = NormalizationUtil.denormalize(normContinuous, value); assertEquals(0.5, result, 0.0001); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "name", "John"); table.put(1, "age", "25"); Map<String, FieldValue> values = new HashMap<>(); values.put("name", new FieldValue("John")); values.put("age", new FieldValue("25")); Map<String, String> expected = new HashMap<>(); expected.put("name", "John"); expected.put("age", "25"); Map<String, String> result = InlineTableUtil.match(table, values); assertEquals(expected, result); }
@Test public void testIsZero() { assertTrue(VerificationUtil.isZero(0, 0.0001)); assertTrue(VerificationUtil.isZero(0.0, 0.0001)); assertTrue(VerificationUtil.isZero(0.00009, 0.0001)); assertTrue(VerificationUtil.isZero(-0.00009, 0.0001)); assertFalse(VerificationUtil.isZero(0.00011, 0.0001)); assertFalse(VerificationUtil.isZero(-0.00011, 0.0001)); }
@Test public void testEvaluateConstant() { Constant constant = new Constant("test", DataType.STRING); EvaluationContext context = new EvaluationContext(); FieldValue result = ExpressionUtil.evaluateConstant(constant, context); assertEquals(DataType.STRING, result.getDataType()); assertEquals("test", result.getValue()); }
@Test public void testUnmarshal() { FieldName name1 = new FieldName("test"); FieldName name2 = FieldName.unmarshal("test"); assertEquals(name1, name2); }
@Test public void testEvaluateSimilarity() { ComparisonMeasure comparisonMeasure = new ComparisonMeasure() { @Override public Measure getMeasure() { return new SimpleMatching(); } }; List<ComparisonField> comparisonFields = new ArrayList<>(); comparisonFields.add(new ComparisonField() { @Override public String getName() { return "field1"; } }); comparisonFields.add(new ComparisonField() { @Override public String getName() { return "field2"; } }); BitSet flags = new BitSet(); flags.set(0); BitSet referenceFlags = new BitSet(); referenceFlags.set(0); Double result = MeasureUtil.evaluateSimilarity(comparisonMeasure, comparisonFields, flags, referenceFlags); assertEquals(1.0, result, 0.0); }
@Test public void testParse() { assertEquals("hello", TypeUtil.parse(DataType.STRING, "hello")); assertEquals(42, TypeUtil.parse(DataType.INTEGER, "42")); assertEquals(3.14f, TypeUtil.parse(DataType.FLOAT, "3.14"), 0.001); assertEquals(2.71828, TypeUtil.parse(DataType.DOUBLE, "2.71828"), 0.00001); assertTrue((boolean) TypeUtil.parse(DataType.BOOLEAN, "true")); assertEquals(LocalDate.of(2022, 10, 31), TypeUtil.parse(DataType.DATE, "2022-10-31")); assertEquals(LocalTime.of(15, 45, 30), TypeUtil.parse(DataType.TIME, "15:45:30")); assertEquals(LocalDateTime.of(2022, 10, 31, 15, 45, 30), TypeUtil.parse(DataType.DATE_TIME, "2022-10-31T15:45:30")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1960, LocalDate.of(2022, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1960, "2440000")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1970, LocalDate.of(2022, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1970, "19668")); assertEquals(new DaysSinceDate(TypeUtil.YEAR_1980, LocalDate.of(2022, 10, 31)), TypeUtil.parse(DataType.DATE_DAYS_SINCE_1980, "8187")); assertEquals(new SecondsSinceMidnight(56730), TypeUtil.parse(DataType.TIME_SECONDS, "15:45:30")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1960, LocalDateTime.of(2022, 10, 31, 15, 45, 30)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1960, "528768330")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1970, LocalDateTime.of(2022, 10, 31, 15, 45, 30)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1970, "1664474730")); assertEquals(new SecondsSinceDate(TypeUtil.YEAR_1980, LocalDateTime.of(2022, 10, 31, 15, 45, 30)), TypeUtil.parse(DataType.DATE_TIME_SECONDS_SINCE_1980, "441444330")); assertThrows(EvaluationException.class, () -> TypeUtil.parse(DataType.UNKNOWN, "unknown")); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testBinaryXor() { assertTrue(PredicateUtil.binaryXor(true, false)); assertTrue(PredicateUtil.binaryXor(false, true)); assertFalse(PredicateUtil.binaryXor(true, true)); assertFalse(PredicateUtil.binaryXor(false, false)); assertNull(PredicateUtil.binaryXor(null, true)); assertNull(PredicateUtil.binaryXor(false, null)); assertNull(PredicateUtil.binaryXor(null, null)); }
@Test public void testDecode() { Object obj1 = "Hello World"; Object obj2 = new Computable() { public Object getResult() { return "Test Passed"; } }; Object result1 = EvaluatorUtil.decode(obj1); Object result2 = EvaluatorUtil.decode(obj2); assertEquals("Hello World", result1); assertEquals("Test Passed", result2); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("foo")); values.add(new FieldValue(42)); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("someFunction"); FunctionUtil.evaluate(apply, values, context); }
@Test public void testMatch() { Table<Integer, String, String> table = HashBasedTable.create(); table.put(1, "Name", "John"); table.put(1, "Age", "30"); table.put(2, "Name", "Jane"); table.put(2, "Age", "25"); Map<String, FieldValue> values = new HashMap<>(); values.put("Name", new FieldValue("John")); values.put("Age", new FieldValue("30")); Map<String, String> expected = table.row(1); Map<String, String> result = InlineTableUtil.match(table, values); assertEquals(expected, result); }
@Test public void evaluate_WhenFunctionExists_ReturnsCorrectValue() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("John")); values.add(new FieldValue("Doe")); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("concat", values); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue("JohnDoe"), result); }
@Test public void testEvaluateMapValues(){ MapValues mapValues = new MapValues(DataType.STRING, "missing", new ArrayList<FieldColumnPair>()); EvaluationContext context = new EvaluationContext(); FieldColumnPair fieldColumnPair1 = new FieldColumnPair("field1", "column1"); FieldColumnPair fieldColumnPair2 = new FieldColumnPair("field2", "column2"); List<FieldColumnPair> fieldColumnPairs = Arrays.asList(fieldColumnPair1, fieldColumnPair2); mapValues.setFieldColumnPairs(fieldColumnPairs); Map<String, FieldValue> values = new LinkedHashMap<>(); FieldValue fieldValue1 = new FieldValue("value1"); FieldValue fieldValue2 = new FieldValue("value2"); values.put("column1", fieldValue1); values.put("column2", fieldValue2); when(DiscretizationUtil.mapValue(mapValues, values)).thenReturn(new FieldValue("mappedValue")); FieldValue result = ExpressionUtil.evaluateMapValues(mapValues, context); assertEquals("mappedValue", result.getValue()); }
@Test public void testEvaluateNormContinuous() { NormContinuous normContinuous = new NormContinuous(); normContinuous.setMapMissingTo(0.0); normContinuous.setField("field1"); normContinuous.setNorm(new ArrayList<>()); Map<String, FieldValue> fields = new HashMap<>(); fields.put("field1", FieldValueUtil.create(50.0)); EvaluationContext context = new EvaluationContext(fields); FieldValue result = ExpressionUtil.evaluateNormContinuous(normContinuous, context); assertNotNull(result); assertEquals(FieldValueType.DOUBLE, result.getType()); assertEquals(0.0, result.asDouble(), 0.001); }
@Test public void testNormalize() { NormContinuous normContinuous = new NormContinuous(0, 10); FieldValue value = FieldValueUtil.create(5); FieldValue result = NormalizationUtil.normalize(normContinuous, value); double expectedResult = 0.5; double actualResult = result.asNumber().doubleValue(); assertEquals(expectedResult, actualResult, 0.0001); }
@Test public void testCast() { Object value = "123"; DataType dataType = DataType.INTEGER; assertEquals(TypeUtil.cast(dataType, value), 123); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("foo")); values.add(new FieldValue(42)); Apply apply = new Apply("functionName"); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testBinaryOr() { assertTrue(PredicateUtil.binaryOr(true, false)); assertTrue(PredicateUtil.binaryOr(false, true)); assertTrue(PredicateUtil.binaryOr(true, true)); assertFalse(PredicateUtil.binaryOr(false, false)); assertNull(PredicateUtil.binaryOr(null, false)); assertNull(PredicateUtil.binaryOr(false, null)); assertNull(PredicateUtil.binaryOr(null, null)); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("test1", FieldType.STRING)); values.add(new FieldValue("test2", FieldType.STRING)); Apply apply = new Apply("functionName"); EvaluationContext context = new EvaluationContext(); FunctionUtil.evaluate(apply, values, context); }
@Test public void testEvaluateNormDiscrete() { NormDiscrete normDiscrete = new NormDiscrete("field", "value", 1.0, 0.0); EvaluationContext context = new EvaluationContext(); context.setFieldValue("field", new FieldValue("value")); FieldValue result = ExpressionUtil.evaluateNormDiscrete(normDiscrete, context); assertEquals(1.0, result.asDouble(), 0.0001); }
@Test public void testEvaluate() { List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("John")); values.add(new FieldValue(25)); values.add(new FieldValue(true)); Apply apply = new Apply("functionName"); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testGetValue() { SparseArray<Integer> sparseArray = new IntSparseArray(); sparseArray.put(0, 10); sparseArray.put(2, 20); sparseArray.put(4, 30); Integer value = SparseArrayUtil.getValue(sparseArray, 2); assertEquals(Integer.valueOf(20), value); }
@Test public void testMarshal() { FieldName name = new FieldName("test"); String marshaledName = FieldName.marshal(name); assertNotNull(marshaledName); assertEquals("test", marshaledName); name = null; marshaledName = FieldName.marshal(name); assertNull(marshaledName); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("value1")); values.add(new FieldValue("value2")); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void prepare_shouldReturnNull_whenDataFieldIsNull() { DataField dataField = null; MiningField miningField = new MiningField(); Object value = new Object(); assertThrows(InvalidFeatureException.class, () -> { ArgumentUtil.prepare(dataField, miningField, value); }); }
@Test public void testEvaluateDiscretize() { Discretize discretize = new Discretize("fieldName", DataType.INTEGER, new HashMap<Double, String>(), "missing"); EvaluationContext context = new EvaluationContext(); context.setFieldValue("fieldName", FieldValueUtil.create(DataType.INTEGER, 5)); FieldValue result = ExpressionUtil.evaluateDiscretize(discretize, context); assertEquals(FieldValueUtil.create(DataType.STRING, "missing"), result); discretize.getMap().put(4.0, "low"); discretize.getMap().put(6.0, "high"); result = ExpressionUtil.evaluateDiscretize(discretize, context); assertEquals(FieldValueUtil.create(DataType.STRING, "low"), result); context.setFieldValue("fieldName", FieldValueUtil.create(DataType.INTEGER, 7)); result = ExpressionUtil.evaluateDiscretize(discretize, context); assertEquals(FieldValueUtil.create(DataType.STRING, "high"), result); }
@Test public void testGetDataType() { Object str = "Hello"; Object integer = 10; Object flt = 10.5f; Object dbl = 10.5; Object bool = true; Object date = LocalDate.now(); Object time = LocalTime.now(); Object dateTime = LocalDateTime.now(); Object daysSinceDate = new DaysSinceDate(LocalDate.of(1960, 1, 1), 10); Object secondsSinceMidnight = new SecondsSinceMidnight(LocalTime.now()); Object secondsSinceDate = new SecondsSinceDate(LocalDate.of(1970, 1, 1), 1000); assertEquals(DataType.STRING, TypeUtil.getDataType(str)); assertEquals(DataType.INTEGER, TypeUtil.getDataType(integer)); assertEquals(DataType.FLOAT, TypeUtil.getDataType(flt)); assertEquals(DataType.DOUBLE, TypeUtil.getDataType(dbl)); assertEquals(DataType.BOOLEAN, TypeUtil.getDataType(bool)); assertEquals(DataType.DATE, TypeUtil.getDataType(date)); assertEquals(DataType.TIME, TypeUtil.getDataType(time)); assertEquals(DataType.DATE_TIME, TypeUtil.getDataType(dateTime)); assertEquals(DataType.DATE_DAYS_SINCE_1960, TypeUtil.getDataType(daysSinceDate)); assertEquals(DataType.TIME_SECONDS, TypeUtil.getDataType(secondsSinceMidnight)); assertEquals(DataType.DATE_TIME_SECONDS_SINCE_1970, TypeUtil.getDataType(secondsSinceDate)); }
@Test public void evaluateTest() { Apply apply = new Apply("functionName"); List<FieldValue> values = Arrays.asList(new FieldValue("value1"), new FieldValue("value2")); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue = FunctionUtil.evaluate(apply, values, context); assertNotNull(fieldValue); }
@Test public void testAcceptable() { Object expected = 5; Object actual = 5.0; double precision = 0.01; double zeroThreshold = 0.001; boolean result = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold); assertTrue(result); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = new ArrayList<>(); EvaluationContext context = new EvaluationContext(); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateFieldRef() { FieldRef fieldRef = new FieldRef("fieldName"); EvaluationContext context = new EvaluationContext(); context.setFieldValue("fieldName", new FieldValue("fieldValue")); FieldValue expectedValue = new FieldValue("fieldValue"); FieldValue actualValue = ExpressionUtil.evaluateFieldRef(fieldRef, context); assertEquals(expectedValue, actualValue); }
@Test public void testIsInvalid() { DataField dataField = new DataField("fieldName", DataType.STRING); Object value = "validValue"; boolean result = ArgumentUtil.isInvalid(dataField, value); assertFalse(result); }
@Test public void testGetConstantDataType() { assertEquals(DataType.INTEGER, TypeUtil.getConstantDataType("123")); assertEquals(DataType.FLOAT, TypeUtil.getConstantDataType("123.45")); assertEquals(DataType.STRING, TypeUtil.getConstantDataType("abc")); }
@Test public void testEvaluate() { Apply apply = new Apply("functionName"); List<FieldValue> values = Arrays.asList(new FieldValue("value1"), new FieldValue("value2")); EvaluationContext context = new EvaluationContext(); FieldValue fieldValue = new FieldValue("result"); Function function = Mockito.mock(Function.class); Mockito.when(function.evaluate(values)).thenReturn(fieldValue); Mockito.when(FunctionUtil.getFunction("functionName")).thenReturn(function); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(result, fieldValue); }
@Test public void testBinaryAnd() { assertTrue(PredicateUtil.binaryAnd(true, true)); assertFalse(PredicateUtil.binaryAnd(true, false)); assertFalse(PredicateUtil.binaryAnd(false, true)); assertFalse(PredicateUtil.binaryAnd(false, false)); assertNull(PredicateUtil.binaryAnd(null, true)); assertNull(PredicateUtil.binaryAnd(null, false)); assertNull(PredicateUtil.binaryAnd(true, null)); assertNull(PredicateUtil.binaryAnd(false, null)); assertNull(PredicateUtil.binaryAnd(null, null)); }
@Test public void testEvaluate() { Apply apply = Mockito.mock(Apply.class); Mockito.when(apply.getFunction()).thenReturn("someFunction"); Function function = Mockito.mock(Function.class); List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("value1")); values.add(new FieldValue("value2")); Mockito.when(function.evaluate(values)).thenReturn(new FieldValue("result")); EvaluationContext context = Mockito.mock(EvaluationContext.class); Mockito.when(context.resolveFunction("someFunction")).thenReturn(null); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertEquals(new FieldValue("result"), result); }
@Test public void testCreate() { String value = "testValue"; FieldName fieldName = FieldName.create(value); assertNotNull(fieldName); assertEquals(value, fieldName.toString()); }
@Test public void testContains() { Interval interval = new Interval(0.0, 5.0, Interval.Closure.CLOSED_CLOSED); assertTrue(DiscretizationUtil.contains(interval, 0.0)); assertTrue(DiscretizationUtil.contains(interval, 5.0)); assertTrue(DiscretizationUtil.contains(interval, 2.5)); assertFalse(DiscretizationUtil.contains(interval, -1.0)); assertFalse(DiscretizationUtil.contains(interval, 6.0)); }
@Test public void evaluateTest(){ List<FieldValue> values = new ArrayList<>(); values.add(new FieldValue("John", "Doe")); values.add(new FieldValue(25)); EvaluationContext context = new EvaluationContext(); Apply apply = new Apply("functionName"); FieldValue result = FunctionUtil.evaluate(apply, values, context); assertNotNull(result); }
@Test public void testEvaluateAggregate() { Aggregate aggregate = new Aggregate(); aggregate.setField(new Field("fieldName")); aggregate.setGroupField(new FieldName("groupName")); aggregate.setFunction(Aggregate.Function.COUNT); EvaluationContext context = new EvaluationContext(); context.setVariable("fieldName", new FieldValue(10)); context.setVariable("groupName", new FieldValue("group1")); FieldValue result = ExpressionUtil.evaluateAggregate(aggregate, context); assertEquals(1, FieldValueUtil.getValue(result)); }
@Test public void testGroupRows() { Map<String, Object> row1 = new HashMap<>(); row1.put("name", "Alice"); row1.put("age", 25); row1.put("city", "New York"); Map<String, Object> row2 = new HashMap<>(); row2.put("name", "Bob"); row2.put("age", 30); row2.put("city", "London"); Map<String, Object> row3 = new HashMap<>(); row3.put("name", "Charlie"); row3.put("age", 25); row3.put("city", "New York"); List<Map<String, Object>> table = new ArrayList<>(); table.add(row1); table.add(row2); table.add(row3); List<Map<String, Object>> resultTable = EvaluatorUtil.groupRows("age", table); assertEquals(2, resultTable.size()); Map<String, Object> resultRow1 = resultTable.get(0); assertEquals(25, resultRow1.get("age")); assertEquals(2, resultRow1.size()); Map<String, Object> resultRow2 = resultTable.get(1); assertEquals(30, resultRow2.get("age")); assertEquals(1, resultRow2.size()); }
@Test public void testCreate() { String value = "test"; FieldName fieldName = FieldName.create(value); assertNotNull(fieldName); assertEquals(value, fieldName.value); }
@Test public void testIsValid() { DataField dataField = new DataField(DataType.INTEGER, OpType.CATEGORICAL); Value validValue1 = new Value("1", Value.Property.VALID); Value validValue2 = new Value("2", Value.Property.VALID); Value invalidValue = new Value("3", Value.Property.INVALID); dataField.addValue(validValue1); dataField.addValue(validValue2); dataField.addValue(invalidValue); assertTrue(ArgumentUtil.isValid(dataField, 1)); assertTrue(ArgumentUtil.isValid(dataField, "2")); assertFalse(ArgumentUtil.isValid(dataField, 3)); assertFalse(ArgumentUtil.isValid(dataField, null)); }
@Test public void testProcess() { Target target = new Target(); target.setMin(5.0); target.setMax(10.0); target.setRescaleFactor(2.0); target.setRescaleConstant(3.0); target.setCastInteger(Target.CastInteger.ROUND); Double value = 7.0; Number result = TargetUtil.process(target, value); assertEquals(17, result); }
@Test public void testChangedLines() { Tracker tracker = new Tracker(); ChangedLinesComputer clc = new ChangedLinesComputer(tracker); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); tracker.updateLine(1); tracker.updateLine(3); tracker.updateLine(5); tracker.updateLine(7); Set<Integer> actual = clc.changedLines(); assertEquals(expected, actual); }
@Test public void testForkDate() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Instant expectedForkDate = Instant.now(); try (Repository repo = gitScmProvider.buildRepo(projectBaseDir)) { Ref targetRef = repo.exactRef("master"); RevCommit commit = repo.commit().setMessage("Test commit").call(); repo.updateRef(targetRef.getName()).setNewObjectId(commit).update(); Optional<RevCommit> mergeBaseCommit = gitScmProvider.findMergeBase(repo, targetRef); Instant actualForkDate = gitScmProvider.forkDate(targetRef.getName(), projectBaseDir); assertEquals(expectedForkDate, actualForkDate); } catch (Exception e) { fail("Exception thrown: " + e.getMessage()); } }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); expected.add(1); expected.add(3); expected.add(5); expected.add(7); expected.add(9); Set<Integer> actual = clc.changedLines(); assertEquals(expected, actual); }
@Test public void testBranchChangedLines() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Paths.get("path/to/project"); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("path/to/changed/file1")); changedFiles.add(Paths.get("path/to/changed/file2")); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("targetBranch", projectBaseDir, changedFiles); assertNotNull(changedLines); assertEquals(2, changedLines.size()); assertTrue(changedLines.containsKey(Paths.get("path/to/changed/file1"))); assertTrue(changedLines.containsKey(Paths.get("path/to/changed/file2"))); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); File baseDir = new File("path/to/base/dir"); when(fileSystem.baseDir()).thenReturn(baseDir); when(input.fileSystem()).thenReturn(fileSystem); InputFile inputFile = mock(InputFile.class); when(inputFile.relativePath()).thenReturn("path/to/file"); when(input.filesToBlame()).thenReturn(Collections.singletonList(inputFile)); Repository repo = mock(Repository.class); Git git = mock(Git.class); when(JGitUtils.buildRepository(baseDir.toPath())).thenReturn(repo); when(Git.wrap(repo)).thenReturn(git); when(repo.getWorkTree()).thenReturn(baseDir); when(this.cloneIsInvalid(baseDir)).thenReturn(false); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); jGitBlameCommand.blame(input, output); verify(output).blameResult(any(BlameResult.class)); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1")); expected.add(rootBaseDir.resolve("file2")); expected.add(rootBaseDir.resolve("dir/file3")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File(".")); when(input.filesToBlame()).thenReturn(Stream.of(mock(InputFile.class))); JGitBlameCommand command = new JGitBlameCommand(pathResolver, analysisWarnings); command.blame(input, output); verify(output, times(1)).blame(any(BlameLine.class)); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("test-repo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "Hello, world!".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("feature-branch").call(); Files.write(filePath, "Goodbye, world!".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modify test.txt").call(); GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("feature-branch", tempDir, Collections.singleton(filePath)); Set<Integer> expectedChangedLines = new HashSet<>(Arrays.asList(1)); assertEquals(expectedChangedLines, changedLines.get(filePath)); } }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("dir/file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("master", rootBaseDir); assertEquals(expected, actual); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(new Tracker()); clc.changedLines().add(1); clc.changedLines().add(2); clc.changedLines().add(3); assertEquals(3, clc.changedLines().size()); }
@Test public void testForkDate() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path projectBaseDir = Files.createTempDirectory("test"); Instant forkDate = gitScmProvider.forkDate("master", projectBaseDir); assertNull(forkDate); }
@Test public void testForkDate() throws Exception { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("test-branch").call(); Files.write(filePath, "modified".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in branch").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Instant forkDate = gitScmProvider.forkDate("test-branch", tempDir); assertNotNull(forkDate); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("test-repo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Git git = Git.open(tempDir.toFile()); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("test-branch").call(); Files.write(filePath, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in test branch").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = provider.branchChangedFiles("test-branch", tempDir); Set<Path> expectedFiles = Collections.singleton(filePath); assertEquals(expectedFiles, changedFiles); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("dir/file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws Exception { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("path/to/repo")); when(input.filesToBlame()).thenReturn(Collections.singletonList(mock(InputFile.class))); JGitBlameCommand command = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); command.blame(input, output); verify(output, times(1)).blame(any(BlameResult.class)); }
@Test public void testBlameCommand() { JGitBlameCommand jgitBlameCommand = new JGitBlameCommand(); AnalysisWarnings analysisWarnings = new AnalysisWarnings(); GitIgnoreCommand gitIgnoreCommand = new GitIgnoreCommand(); System2 system2 = new System2(); GitScmProvider gitScmProvider = new GitScmProvider(jgitBlameCommand, analysisWarnings, gitIgnoreCommand, system2); BlameCommand blameCommand = gitScmProvider.blameCommand(); assertNotNull(blameCommand); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("/path/to/repository/file.txt"); Path expected = Paths.get("file.txt"); Path actual = gitScmProvider.relativePathFromScmRoot(path); assertEquals(expected, actual); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "Hello, world!".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("test-branch").call(); Files.write(filePath, "Modified text".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified file in test-branch").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(filePath); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("test-branch", tempDir, changedFiles); assertEquals(1, changedLines.size()); assertTrue(changedLines.containsKey(filePath)); assertEquals(1, changedLines.get(filePath).size()); assertTrue(changedLines.get(filePath).contains(1)); FileUtils.deleteDirectory(tempDir.toFile()); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("src/test/resources")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("file1.txt"), new InputFile("file2.txt"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blameResult(any(BlameResult.class)); }
@Test public void testBlameCommand() throws Exception { PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("path/to/repo")); when(input.filesToBlame()).thenReturn(Collections.singletonList(mock(InputFile.class)).stream()); jGitBlameCommand.blame(input, output); verify(output, times(1)).blame(any()); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Git git = Git.open(tempDir.toFile()); Path file1 = tempDir.resolve("file1.txt"); Files.write(file1, "test content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("initial commit").call(); git.branchCreate().setName("test-branch").call(); git.checkout().setName("test-branch").call(); Files.write(file1, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("modified file1").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("master", tempDir); assertTrue(changedFiles.contains(file1)); FileUtils.deleteDirectory(tempDir.toFile()); }
@Test public void testKey() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); assertEquals("git", gitScmProvider.key()); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Repository repo = new FileRepositoryBuilder().setGitDir(tempDir.resolve(".git").toFile()).build(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, Collections.singletonList("test")); Git git = new Git(repo); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("test-branch").call(); Path newFilePath = tempDir.resolve("new.txt"); Files.write(newFilePath, Collections.singletonList("new")); git.add().addFilepattern(".").call(); git.commit().setMessage("Added new file").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = provider.branchChangedFiles("test-branch", tempDir); assertEquals(1, changedFiles.size()); assertTrue(changedFiles.contains(newFilePath)); git.close(); repo.close(); FileUtils.deleteDirectory(tempDir.toFile()); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/base/dir"); Set<Path> expectedPaths = new HashSet<>(); expectedPaths.add(rootBaseDir.resolve("path/to/added/file")); expectedPaths.add(rootBaseDir.resolve("path/to/modified/file")); Set<Path> actualPaths = gitScmProvider.branchChangedFiles("targetBranchName", rootBaseDir); assertEquals(expectedPaths, actualPaths); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), System2.INSTANCE); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = provider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); try { Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "Hello, world!".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "Goodbye, world!".getBytes()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Modify file on testBranch").call(); GitScmProvider provider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = Collections.singleton(filePath); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("testBranch", tempDir, changedFiles); Set<Integer> expectedLines = new HashSet<>(Arrays.asList(1, 2)); assertEquals(expectedLines, changedLines.get(filePath)); } finally { FileUtils.deleteDirectory(tempDir.toFile()); } }
@Test public void testSupports() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); File baseDir = new File("path/to/base/dir"); boolean result = gitScmProvider.supports(baseDir); assertTrue(result); }
@Test public void testBranchChangedFiles() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("file1.txt")); expected.add(rootBaseDir.resolve("file2.txt")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranch", rootBaseDir); assertEquals(expected, actual); }
@Test public void testNewThread() { ForkJoinPool pool = new ForkJoinPool(); GitThreadFactory factory = new GitThreadFactory(); ForkJoinWorkerThread thread = factory.newThread(pool); assertNotNull(thread); assertTrue(thread.getName().startsWith("GitThread")); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("testFile.txt"); Files.write(filePath, "Hello, world!".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("testBranch").call(); Files.write(filePath, "Goodbye, world!".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified testFile.txt").call(); GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("testBranch", tempDir, Collections.singleton(filePath)); Set<Integer> expectedLines = new HashSet<>(Arrays.asList(1)); assertEquals(expectedLines, changedLines.get(filePath)); }
@Test public void testBranchChangedLines() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(Paths.get("file1.java")); changedFiles.add(Paths.get("file2.java")); Map<Path, Set<Integer>> changedLines = gitScmProvider.branchChangedLines("master", Paths.get("/project/base/dir"), changedFiles); assertNotNull(changedLines); assertEquals(2, changedLines.size()); assertTrue(changedLines.containsKey(Paths.get("file1.java"))); assertTrue(changedLines.containsKey(Paths.get("file2.java"))); }
@Test public void testDefine() { Context context = mock(Context.class); GitPlugin gitPlugin = new GitPlugin(); gitPlugin.define(context); verify(context).addExtensions(JGitBlameCommand.class, GitScmProvider.class, GitIgnoreCommand.class); }
@Test public void testBranchChangedFiles() throws Exception { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(Paths.get("path/to/changed/file1")); expected.add(Paths.get("path/to/changed/file2")); Set<Path> actual = gitScmProvider.branchChangedFiles("targetBranchName", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("src/test/resources")); when(input.filesToBlame()).thenReturn(Arrays.asList(new InputFile("file1.txt"), new InputFile("file2.txt"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); jGitBlameCommand.blame(input, output); verify(output, times(1)).blameResult(any(BlameResult.class)); }
@Test public void testRelativePathFromScmRoot() { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("path/to/file"); Path expected = Paths.get("to/file"); assertEquals(expected, gitScmProvider.relativePathFromScmRoot(path)); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get(System.getProperty("user.dir")); Set<Path> expected = new HashSet<>(); expected.add(rootBaseDir.resolve("src/main/java/com/example/TestClass.java")); Set<Path> actual = provider.branchChangedFiles("master", rootBaseDir); assertEquals(expected, actual); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("test-repo"); try (Git git = Git.init().setDirectory(tempDir.toFile()).call()) { Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, Arrays.asList("line 1", "line 2", "line 3")); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Initial commit").call(); git.branchCreate().setName("test-branch").call(); Files.write(filePath, Arrays.asList("line 1", "line 2 (modified)", "line 3")); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Modify test.txt on test-branch").call(); GitScmProvider scmProvider = new GitScmProvider(null, null, null, null); Map<Path, Set<Integer>> changedLines = scmProvider.branchChangedLines("test-branch", tempDir, Collections.singleton(filePath)); assertEquals(1, changedLines.size()); assertTrue(changedLines.containsKey(filePath)); assertEquals(new HashSet<>(Arrays.asList(2)), changedLines.get(filePath)); } }
@Test public void testForkDate() throws Exception { Path projectBaseDir = Paths.get("path/to/project"); GitScmProvider scmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Instant forkDate = scmProvider.forkDate("master", projectBaseDir); assertNotNull(forkDate); }
@Test public void testChangedLines() { ChangedLinesComputer computer = new ChangedLinesComputer(); Set<Integer> expected = new HashSet<>(); assertEquals(expected, computer.changedLines()); }
@Test public void testRelativePathFromScmRoot() throws IOException { GitScmProvider provider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path root = Paths.get("/home/user/git/repo/"); Path path = root.resolve("src/main/java/com/example/App.java"); Path result = provider.relativePathFromScmRoot(path); Path expected = Paths.get("src/main/java/com/example/App.java"); assertEquals(expected, result); }
@Test public void testRevisionId() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path path = Paths.get("path/to/repo"); String revisionId = gitScmProvider.revisionId(path); assertNotNull(revisionId); }
@Test public void testBranchChangedFiles() throws IOException, GitAPIException { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Git git = Git.open(tempDir.toFile()); Path newFile = tempDir.resolve("newFile.txt"); Files.createFile(newFile); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("newBranch").call(); Path newFileInBranch = tempDir.resolve("newFileInBranch.txt"); Files.createFile(newFileInBranch); git.add().addFilepattern(".").call(); git.commit().setMessage("Commit in new branch").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Set<Path> changedFiles = gitScmProvider.branchChangedFiles("newBranch", tempDir); Set<Path> expectedChangedFiles = new HashSet<>(); expectedChangedFiles.add(newFileInBranch); assertEquals(expectedChangedFiles, changedFiles); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); when(input.fileSystem()).thenReturn(mock(FileSystem.class)); when(input.fileSystem().baseDir()).thenReturn(new File(".")); when(input.filesToBlame()).thenReturn(Collections.singletonList(mock(InputFile.class)).stream()); BlameOutput output = mock(BlameOutput.class); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(mock(PathResolver.class), mock(AnalysisWarnings.class)); jGitBlameCommand.blame(input, output); verify(output, times(1)).blameResult(any(BlameResult.class)); }
@Test public void testBranchChangedLines() throws Exception { Path tempDir = Files.createTempDirectory("testRepo"); Git.init().setDirectory(tempDir.toFile()).call().close(); Path testFile = tempDir.resolve("test.txt"); Files.write(testFile, "test content".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern(".").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("testBranch").call(); Files.write(testFile, "modified content".getBytes()); git.add().addFilepattern(".").call(); git.commit().setMessage("Modified test file").call(); Set<Path> changedFiles = new HashSet<>(); changedFiles.add(testFile); GitScmProvider provider = new GitScmProvider(null, null, null, null); Map<Path, Set<Integer>> changedLines = provider.branchChangedLines("testBranch", tempDir, changedFiles); assertEquals(1, changedLines.size()); assertTrue(changedLines.containsKey(testFile)); assertEquals(new HashSet<>(Arrays.asList(1, 2)), changedLines.get(testFile)); }
@Test public void testForkDate() throws Exception { Path tempDir = Files.createTempDirectory("test"); Git.init().setDirectory(tempDir.toFile()).call(); Path filePath = tempDir.resolve("test.txt"); Files.write(filePath, "test".getBytes()); Git git = Git.open(tempDir.toFile()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Initial commit").call(); git.checkout().setCreateBranch(true).setName("test-branch").call(); Files.write(filePath, "test2".getBytes()); git.add().addFilepattern("test.txt").call(); git.commit().setMessage("Commit on test-branch").call(); GitScmProvider gitScmProvider = new GitScmProvider(null, null, null, null); Instant forkDate = gitScmProvider.forkDate("test-branch", tempDir); assertEquals(forkDate, Instant.ofEpochSecond(git.log().add(git.getRepository().resolve("test-branch")).call().iterator().next().getCommitTime())); }
@Test public void testChangedLines() { ChangedLinesComputer clc = new ChangedLinesComputer(tracker); Set<Integer> expected = new HashSet<Integer>(); expected.add(10); expected.add(20); expected.add(30); expected.add(40); expected.add(50); Set<Integer> result = clc.changedLines(); assertEquals(expected, result); }
@Test public void testBlame() throws IOException { BlameInput input = mock(BlameInput.class); BlameOutput output = mock(BlameOutput.class); FileSystem fileSystem = mock(FileSystem.class); PathResolver pathResolver = mock(PathResolver.class); AnalysisWarnings analysisWarnings = mock(AnalysisWarnings.class); when(input.fileSystem()).thenReturn(fileSystem); when(fileSystem.baseDir()).thenReturn(new File("src/test/resources")); when(input.filesToBlame()).thenReturn(Collections.singletonList(new InputFile("testFile.txt"))); JGitBlameCommand jGitBlameCommand = new JGitBlameCommand(pathResolver, analysisWarnings); jGitBlameCommand.blame(input, output); verify(output, times(1)).blameResult(any()); }
@Test public void testBranchChangedFiles() throws IOException { GitScmProvider gitScmProvider = new GitScmProvider(new JGitBlameCommand(), new AnalysisWarnings(), new GitIgnoreCommand(), new System2()); Path rootBaseDir = Paths.get("path/to/root/dir"); Set<Path> expected = new HashSet<>(); expected.add(Paths.get("path/to/added/file")); expected.add(Paths.get("path/to/modified/file")); Set<Path> result = gitScmProvider.branchChangedFiles("targetBranchName", rootBaseDir); assertEquals(expected, result); }